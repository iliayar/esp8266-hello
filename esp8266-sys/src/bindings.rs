/* automatically generated by rust-bindgen 0.57.0 */

pub const CONFIG_IDF_TARGET_ESP8266: u32 = 1;
pub const CONFIG_IDF_TARGET: &'static [u8; 8usize] = b"esp8266\0";
pub const CONFIG_SDK_TOOLPREFIX: &'static [u8; 18usize] = b"xtensa-lx106-elf-\0";
pub const CONFIG_SDK_PYTHON: &'static [u8; 7usize] = b"python\0";
pub const CONFIG_BOOTLOADER_INIT_SPI_FLASH: u32 = 1;
pub const CONFIG_LOG_BOOTLOADER_LEVEL_INFO: u32 = 1;
pub const CONFIG_LOG_BOOTLOADER_LEVEL: u32 = 3;
pub const CONFIG_BOOTLOADER_STORE_OFFSET: u32 = 0;
pub const CONFIG_ESPTOOLPY_PORT: &'static [u8; 13usize] = b"/dev/ttyUSB0\0";
pub const CONFIG_ESPTOOLPY_BAUD_115200B: u32 = 1;
pub const CONFIG_ESPTOOLPY_BAUD_OTHER_VAL: u32 = 115200;
pub const CONFIG_ESPTOOLPY_BAUD: u32 = 115200;
pub const CONFIG_ESPTOOLPY_COMPRESSED: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE_QIO: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE: &'static [u8; 4usize] = b"dio\0";
pub const CONFIG_SPI_FLASH_MODE: u32 = 0;
pub const CONFIG_ESPTOOLPY_FLASHFREQ_40M: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ: &'static [u8; 4usize] = b"40m\0";
pub const CONFIG_SPI_FLASH_FREQ: u32 = 0;
pub const CONFIG_ESPTOOLPY_FLASHSIZE_2MB: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHSIZE: &'static [u8; 4usize] = b"2MB\0";
pub const CONFIG_SPI_FLASH_SIZE: u32 = 2097152;
pub const CONFIG_ESPTOOLPY_BEFORE_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE: &'static [u8; 14usize] = b"default_reset\0";
pub const CONFIG_ESPTOOLPY_AFTER_HARD_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_AFTER: &'static [u8; 11usize] = b"hard_reset\0";
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD_74880B: u32 = 1;
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD_OTHER_VAL: u32 = 74880;
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD: u32 = 74880;
pub const CONFIG_PARTITION_TABLE_SINGLE_APP: u32 = 1;
pub const CONFIG_PARTITION_TABLE_CUSTOM_FILENAME: &'static [u8; 15usize] = b"partitions.csv\0";
pub const CONFIG_PARTITION_TABLE_OFFSET: u32 = 32768;
pub const CONFIG_PARTITION_TABLE_FILENAME: &'static [u8; 25usize] = b"partitions_singleapp.csv\0";
pub const CONFIG_COMPILER_OPTIMIZATION_LEVEL_DEBUG: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE: u32 = 1;
pub const CONFIG_COMPILER_STACK_CHECK_MODE_NONE: u32 = 1;
pub const CONFIG_APP_UPDATE_CHECK_APP_SUM: u32 = 1;
pub const CONFIG_APP_COMPILE_TIME_DATE: u32 = 1;
pub const CONFIG_ESP_TLS_USING_MBEDTLS: u32 = 1;
pub const CONFIG_ESP8266_NMI_WDT: u32 = 1;
pub const CONFIG_ESP8266_XTAL_FREQ_26: u32 = 1;
pub const CONFIG_ESP8266_XTAL_FREQ: u32 = 26;
pub const CONFIG_ESP8266_DEFAULT_CPU_FREQ_160: u32 = 1;
pub const CONFIG_ESP8266_DEFAULT_CPU_FREQ_MHZ: u32 = 160;
pub const CONFIG_ESP_FILENAME_MACRO_NO_PATH: u32 = 1;
pub const CONFIG_USING_NEW_ETS_VPRINTF: u32 = 1;
pub const CONFIG_ETS_PRINTF_EXIT_WHEN_FLASH_RW: u32 = 1;
pub const CONFIG_SOC_IRAM_SIZE: u32 = 49152;
pub const CONFIG_ESP_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_RESET_REASON: u32 = 1;
pub const CONFIG_WIFI_PPT_TASKSTACK_SIZE: u32 = 5120;
pub const CONFIG_ESP8266_CORE_GLOBAL_DATA_LINK_IRAM: u32 = 1;
pub const CONFIG_ESP8266_TIME_SYSCALL_USE_FRC1: u32 = 1;
pub const CONFIG_SCAN_AP_MAX: u32 = 99;
pub const CONFIG_WIFI_TX_RATE_SEQUENCE_FROM_HIGH: u32 = 1;
pub const CONFIG_ESP8266_WIFI_RX_BUFFER_NUM: u32 = 16;
pub const CONFIG_ESP8266_WIFI_LEFT_CONTINUOUS_RX_BUFFER_NUM: u32 = 16;
pub const CONFIG_ESP8266_WIFI_RX_PKT_NUM: u32 = 7;
pub const CONFIG_ESP8266_WIFI_TX_PKT_NUM: u32 = 6;
pub const CONFIG_ESP8266_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_ESP8266_WIFI_CONNECT_OPEN_ROUTER_WHEN_PWD_IS_SET: u32 = 1;
pub const CONFIG_ESP8266_WIFI_ENABLE_WPA3_SAE: u32 = 1;
pub const CONFIG_ESP_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ESP_PHY_INIT_DATA_VDD33_CONST: u32 = 33;
pub const CONFIG_ESP8266_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP_ERR_TO_NAME_LOOKUP: u32 = 1;
pub const CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2048;
pub const CONFIG_ESP_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP_CONSOLE_UART_BAUDRATE: u32 = 74880;
pub const CONFIG_ESP_TASK_WDT: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_PANIC: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_TIMEOUT_15N: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_TIMEOUT_S: u32 = 15;
pub const CONFIG_ESP_EVENT_POST_FROM_ISR: u32 = 1;
pub const CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS: u32 = 1;
pub const CONFIG_HTTP_BUF_SIZE: u32 = 512;
pub const CONFIG_HTTPD_MAX_REQ_HDR_LEN: u32 = 512;
pub const CONFIG_HTTPD_MAX_URI_LEN: u32 = 512;
pub const CONFIG_OTA_BUF_SIZE: u32 = 256;
pub const CONFIG_FATFS_CODEPAGE_437: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE: u32 = 437;
pub const CONFIG_FATFS_LFN_NONE: u32 = 1;
pub const CONFIG_FATFS_FS_LOCK: u32 = 0;
pub const CONFIG_FATFS_TIMEOUT_MS: u32 = 10000;
pub const CONFIG_FATFS_PER_FILE_CACHE: u32 = 1;
pub const CONFIG_FMB_COMM_MODE_TCP_EN: u32 = 1;
pub const CONFIG_FMB_TCP_PORT_DEFAULT: u32 = 502;
pub const CONFIG_FMB_TCP_PORT_MAX_CONN: u32 = 5;
pub const CONFIG_FMB_TCP_CONNECTION_TOUT_SEC: u32 = 20;
pub const CONFIG_FMB_MASTER_TIMEOUT_MS_RESPOND: u32 = 150;
pub const CONFIG_FMB_MASTER_DELAY_MS_CONVERT: u32 = 200;
pub const CONFIG_FMB_QUEUE_LENGTH: u32 = 20;
pub const CONFIG_FMB_PORT_TASK_STACK_SIZE: u32 = 4096;
pub const CONFIG_FMB_SERIAL_BUF_SIZE: u32 = 256;
pub const CONFIG_FMB_PORT_TASK_PRIO: u32 = 10;
pub const CONFIG_FMB_CONTROLLER_SLAVE_ID_SUPPORT: u32 = 1;
pub const CONFIG_FMB_CONTROLLER_SLAVE_ID: u32 = 1122867;
pub const CONFIG_FMB_CONTROLLER_NOTIFY_TIMEOUT: u32 = 20;
pub const CONFIG_FMB_CONTROLLER_NOTIFY_QUEUE_SIZE: u32 = 20;
pub const CONFIG_FMB_CONTROLLER_STACK_SIZE: u32 = 4096;
pub const CONFIG_FMB_EVENT_QUEUE_TIMEOUT: u32 = 20;
pub const CONFIG_FMB_TIMER_GROUP: u32 = 0;
pub const CONFIG_FMB_TIMER_INDEX: u32 = 0;
pub const CONFIG_FREERTOS_UNICORE: u32 = 1;
pub const CONFIG_FREERTOS_NO_AFFINITY: u32 = 2147483647;
pub const CONFIG_FREERTOS_HZ: u32 = 100;
pub const CONFIG_FREERTOS_MAX_HOOK: u32 = 2;
pub const CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: u32 = 1024;
pub const CONFIG_FREERTOS_ISR_STACKSIZE: u32 = 512;
pub const CONFIG_FREERTOS_GLOBAL_DATA_LINK_IRAM: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_STACKSIZE: u32 = 2048;
pub const CONFIG_TASK_SWITCH_FASTER: u32 = 1;
pub const CONFIG_FREERTOS_WATCHPOINT_END_OF_STACK: u32 = 1;
pub const CONFIG_LIBSODIUM_USE_MBEDTLS_SHA: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL_INFO: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL: u32 = 3;
pub const CONFIG_LOG_COLORS: u32 = 1;
pub const CONFIG_LWIP_LOCAL_HOSTNAME: &'static [u8; 10usize] = b"espressif\0";
pub const CONFIG_LWIP_DNS_SUPPORT_MDNS_QUERIES: u32 = 1;
pub const CONFIG_LWIP_TIMERS_ONDEMAND: u32 = 1;
pub const CONFIG_LWIP_MAX_SOCKETS: u32 = 10;
pub const CONFIG_LWIP_SO_REUSE: u32 = 1;
pub const CONFIG_LWIP_SO_REUSE_RXTOALL: u32 = 1;
pub const CONFIG_LWIP_IP4_FRAG: u32 = 1;
pub const CONFIG_LWIP_IP6_FRAG: u32 = 1;
pub const CONFIG_LWIP_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_LWIP_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_LWIP_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_LWIP_DHCP_DOES_ARP_CHECK: u32 = 1;
pub const CONFIG_LWIP_DHCPS_LEASE_UNIT: u32 = 60;
pub const CONFIG_LWIP_DHCPS_MAX_STATION_NUM: u32 = 8;
pub const CONFIG_LWIP_NETIF_LOOPBACK: u32 = 1;
pub const CONFIG_LWIP_LOOPBACK_MAX_PBUFS: u32 = 8;
pub const CONFIG_LWIP_MAX_ACTIVE_TCP: u32 = 16;
pub const CONFIG_LWIP_MAX_LISTENING_TCP: u32 = 16;
pub const CONFIG_LWIP_TCP_MAXRTX: u32 = 12;
pub const CONFIG_LWIP_TCP_SYNMAXRTX: u32 = 6;
pub const CONFIG_LWIP_TCP_MSS: u32 = 1440;
pub const CONFIG_LWIP_TCP_TMR_INTERVAL: u32 = 250;
pub const CONFIG_LWIP_TCP_MSL: u32 = 60000;
pub const CONFIG_LWIP_TCP_SND_BUF_DEFAULT: u32 = 2880;
pub const CONFIG_LWIP_TCP_WND_DEFAULT: u32 = 5760;
pub const CONFIG_LWIP_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_LWIP_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_LWIP_TCP_RTO_TIME: u32 = 3000;
pub const CONFIG_LWIP_MAX_UDP_PCBS: u32 = 16;
pub const CONFIG_LWIP_UDP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_TCPIP_TASK_STACK_SIZE: u32 = 2048;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_LWIP_IPV6_MEMP_NUM_ND6_QUEUE: u32 = 3;
pub const CONFIG_LWIP_IPV6_ND6_NUM_NEIGHBORS: u32 = 5;
pub const CONFIG_LWIP_MAX_RAW_PCBS: u32 = 16;
pub const CONFIG_LWIP_DHCP_MAX_NTP_SERVERS: u32 = 1;
pub const CONFIG_LWIP_SNTP_UPDATE_DELAY: u32 = 3600000;
pub const CONFIG_LWIP_ESP_LWIP_ASSERT: u32 = 1;
pub const CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC: u32 = 1;
pub const CONFIG_MBEDTLS_ASYMMETRIC_CONTENT_LEN: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_IN_CONTENT_LEN: u32 = 16384;
pub const CONFIG_MBEDTLS_SSL_OUT_CONTENT_LEN: u32 = 4096;
pub const CONFIG_MBEDTLS_HAVE_TIME: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_DHE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_RENEGOTIATION: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_1: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_2: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_ALPN: u32 = 1;
pub const CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_AES_C: u32 = 1;
pub const CONFIG_MBEDTLS_RC4_DISABLED: u32 = 1;
pub const CONFIG_MBEDTLS_CCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_GCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_WRITE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CRL_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CSR_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDH_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_NIST_OPTIM: u32 = 1;
pub const CONFIG_ESP_AES: u32 = 1;
pub const CONFIG_ESP_MD5: u32 = 1;
pub const CONFIG_ESP_ARC4: u32 = 1;
pub const CONFIG_MQTT_PROTOCOL_311: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_SSL: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE: u32 = 1;
pub const CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF: u32 = 1;
pub const CONFIG_NEWLIB_NANO_FORMAT: u32 = 1;
pub const CONFIG_OPENSSL_ASSERT_DO_NOTHING: u32 = 1;
pub const CONFIG_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_PTHREAD_TASK_NAME_DEFAULT: &'static [u8; 8usize] = b"pthread\0";
pub const CONFIG_SPIFFS_MAX_PARTITIONS: u32 = 3;
pub const CONFIG_SPIFFS_CACHE: u32 = 1;
pub const CONFIG_SPIFFS_CACHE_WR: u32 = 1;
pub const CONFIG_SPIFFS_PAGE_CHECK: u32 = 1;
pub const CONFIG_SPIFFS_GC_MAX_RUNS: u32 = 10;
pub const CONFIG_SPIFFS_PAGE_SIZE: u32 = 256;
pub const CONFIG_SPIFFS_OBJ_NAME_LEN: u32 = 32;
pub const CONFIG_SPIFFS_USE_MAGIC: u32 = 1;
pub const CONFIG_SPIFFS_USE_MAGIC_LENGTH: u32 = 1;
pub const CONFIG_SPIFFS_META_LENGTH: u32 = 4;
pub const CONFIG_SPIFFS_USE_MTIME: u32 = 1;
pub const CONFIG_IP_LOST_TIMER_INTERVAL: u32 = 120;
pub const CONFIG_TCPIP_ADAPTER_GLOBAL_DATA_LINK_IRAM: u32 = 1;
pub const CONFIG_VFS_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_VFS_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_SEMIHOSTFS_MAX_MOUNT_POINTS: u32 = 1;
pub const CONFIG_SEMIHOSTFS_HOST_PATH_MAX_LEN: u32 = 128;
pub const CONFIG_WL_SECTOR_SIZE_4096: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE: u32 = 4096;
pub const CONFIG_LTM_FAST: u32 = 1;
pub const CONFIG_WPA_MBEDTLS_CRYPTO: u32 = 1;
pub const CONFIG_CONSOLE_UART_BAUDRATE: u32 = 74880;
pub const CONFIG_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP32_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_ESP32_PTHREAD_TASK_NAME_DEFAULT: &'static [u8; 8usize] = b"pthread\0";
pub const CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_FLASHMODE_QIO: u32 = 1;
pub const CONFIG_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_MB_CONTROLLER_NOTIFY_QUEUE_SIZE: u32 = 20;
pub const CONFIG_MB_CONTROLLER_NOTIFY_TIMEOUT: u32 = 20;
pub const CONFIG_MB_CONTROLLER_SLAVE_ID: u32 = 1122867;
pub const CONFIG_MB_CONTROLLER_SLAVE_ID_SUPPORT: u32 = 1;
pub const CONFIG_MB_CONTROLLER_STACK_SIZE: u32 = 4096;
pub const CONFIG_MB_EVENT_QUEUE_TIMEOUT: u32 = 20;
pub const CONFIG_MB_MASTER_DELAY_MS_CONVERT: u32 = 200;
pub const CONFIG_MB_MASTER_TIMEOUT_MS_RESPOND: u32 = 150;
pub const CONFIG_MB_QUEUE_LENGTH: u32 = 20;
pub const CONFIG_MB_SERIAL_BUF_SIZE: u32 = 256;
pub const CONFIG_MB_SERIAL_TASK_PRIO: u32 = 10;
pub const CONFIG_MB_SERIAL_TASK_STACK_SIZE: u32 = 4096;
pub const CONFIG_MB_TIMER_GROUP: u32 = 0;
pub const CONFIG_MB_TIMER_INDEX: u32 = 0;
pub const CONFIG_MONITOR_BAUD: u32 = 74880;
pub const CONFIG_MONITOR_BAUD_74880B: u32 = 1;
pub const CONFIG_MONITOR_BAUD_OTHER_VAL: u32 = 74880;
pub const CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED: u32 = 1;
pub const CONFIG_OPTIMIZATION_LEVEL_DEBUG: u32 = 1;
pub const CONFIG_STACK_CHECK_NONE: u32 = 1;
pub const CONFIG_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_TARGET_PLATFORM: &'static [u8; 8usize] = b"esp8266\0";
pub const CONFIG_TASK_WDT: u32 = 1;
pub const CONFIG_TASK_WDT_PANIC: u32 = 1;
pub const CONFIG_TASK_WDT_TIMEOUT_S: u32 = 15;
pub const CONFIG_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_TCPIP_TASK_STACK_SIZE: u32 = 2048;
pub const CONFIG_TCP_MAXRTX: u32 = 12;
pub const CONFIG_TCP_MSL: u32 = 60000;
pub const CONFIG_TCP_MSS: u32 = 1440;
pub const CONFIG_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_TCP_SND_BUF_DEFAULT: u32 = 2880;
pub const CONFIG_TCP_SYNMAXRTX: u32 = 6;
pub const CONFIG_TCP_WND_DEFAULT: u32 = 5760;
pub const CONFIG_TOOLPREFIX: &'static [u8; 18usize] = b"xtensa-lx106-elf-\0";
pub const CONFIG_UDP_RECVMBOX_SIZE: u32 = 6;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 33;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 32;
pub const __WORDSIZE32_SIZE_ULONG: u32 = 0;
pub const __WORDSIZE32_PTRDIFF_LONG: u32 = 0;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 32;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 0;
pub const __STATFS_MATCHES_STATFS64: u32 = 0;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 0;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 24;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 36;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 32;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 20;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 0;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const ETS_INT_MASK: u32 = 16383;
pub const ESP_TICKS_MAX: u32 = 4294967295;
pub const BIT31: u32 = 2147483648;
pub const BIT30: u32 = 1073741824;
pub const BIT29: u32 = 536870912;
pub const BIT28: u32 = 268435456;
pub const BIT27: u32 = 134217728;
pub const BIT26: u32 = 67108864;
pub const BIT25: u32 = 33554432;
pub const BIT24: u32 = 16777216;
pub const BIT23: u32 = 8388608;
pub const BIT22: u32 = 4194304;
pub const BIT21: u32 = 2097152;
pub const BIT20: u32 = 1048576;
pub const BIT19: u32 = 524288;
pub const BIT18: u32 = 262144;
pub const BIT17: u32 = 131072;
pub const BIT16: u32 = 65536;
pub const BIT15: u32 = 32768;
pub const BIT14: u32 = 16384;
pub const BIT13: u32 = 8192;
pub const BIT12: u32 = 4096;
pub const BIT11: u32 = 2048;
pub const BIT10: u32 = 1024;
pub const BIT9: u32 = 512;
pub const BIT8: u32 = 256;
pub const BIT7: u32 = 128;
pub const BIT6: u32 = 64;
pub const BIT5: u32 = 32;
pub const BIT4: u32 = 16;
pub const BIT3: u32 = 8;
pub const BIT2: u32 = 4;
pub const BIT1: u32 = 2;
pub const BIT0: u32 = 1;
pub const CPU_CLK_FREQ: u32 = 80000000;
pub const APB_CLK_FREQ: u32 = 80000000;
pub const UART_CLK_FREQ: u32 = 80000000;
pub const TIMER_CLK_FREQ: u32 = 312500;
pub const FREQ_1MHZ: u32 = 1000000;
pub const FREQ_1KHZ: u32 = 1000;
pub const CPU_FREQ_160MHZ: u32 = 160000000;
pub const CPU_FREQ_80MHz: u32 = 80000000;
pub const CPU_160M_TICKS_PRT_MS: u32 = 160000;
pub const CPU_80M_TICKS_PRT_MS: u32 = 80000;
pub const CPU_160M_TICKS_PRT_US: u32 = 160;
pub const CPU_80M_TICKS_PRT_US: u32 = 80;
pub const PERIPHS_DPORT_BASEADDR: u32 = 1072693248;
pub const PERIPHS_RTC_BASEADDR: u32 = 1610614528;
pub const HOST_INF_SEL: u32 = 1072693288;
pub const DPORT_LINK_DEVICE_SEL: u32 = 255;
pub const DPORT_LINK_DEVICE_SEL_S: u32 = 8;
pub const DPORT_PERI_IO_SWAP: u32 = 255;
pub const DPORT_PERI_IO_SWAP_S: u32 = 0;
pub const NMI_INT_ENABLE_REG: u32 = 1072693248;
pub const EDGE_INT_ENABLE_REG: u32 = 1072693252;
pub const DPORT_CTL_REG: u32 = 1072693268;
pub const DPORT_CTL_DOUBLE_CLK: u32 = 1;
pub const INT_ENA_WDEV: u32 = 1072827416;
pub const WDEV_COUNT_REG: u32 = 1072827392;
pub const WDEVTSF0_TIME_LO: u32 = 1072828420;
pub const WDEVTSF0_TIME_HI: u32 = 1072828424;
pub const WDEVSLEEP0_CONF: u32 = 1072828436;
pub const WDEVTSFSW0_LO: u32 = 1072828440;
pub const WDEVTSFSW0_HI: u32 = 1072828444;
pub const WDEVTSF0_TIMER_LO: u32 = 1072828572;
pub const WDEVTSF0_TIMER_HI: u32 = 1072828576;
pub const WDEVTSF0TIMER_ENA: u32 = 1072828568;
pub const PERIPHS_WDT_BASEADDR: u32 = 1610615040;
pub const WDT_CTL_ADDRESS: u32 = 0;
pub const WDT_OP_ADDRESS: u32 = 4;
pub const WDT_OP_ND_ADDRESS: u32 = 8;
pub const WDT_RST_ADDRESS: u32 = 20;
pub const WDT_CTL_RSTLEN_MASK: u32 = 56;
pub const WDT_CTL_RSPMOD_MASK: u32 = 6;
pub const WDT_CTL_EN_MASK: u32 = 1;
pub const WDT_CTL_RSTLEN_LSB: u32 = 3;
pub const WDT_CTL_RSPMOD_LSB: u32 = 1;
pub const WDT_CTL_EN_LSB: u32 = 0;
pub const WDT_FEED_VALUE: u32 = 115;
pub const REG_RTC_BASE: u32 = 1610614528;
pub const RTC_SLP_VAL: u32 = 1610614532;
pub const RTC_SLP_CNT_VAL: u32 = 1610614556;
pub const RTC_SCRATCH0: u32 = 1610614576;
pub const RTC_SCRATCH1: u32 = 1610614580;
pub const RTC_SCRATCH2: u32 = 1610614584;
pub const RTC_SCRATCH3: u32 = 1610614588;
pub const RTC_GPIO_OUT: u32 = 1610614632;
pub const RTC_GPIO_ENABLE: u32 = 1610614644;
pub const RTC_GPIO_IN_DATA: u32 = 1610614668;
pub const RTC_GPIO_CONF: u32 = 1610614672;
pub const PAD_XPD_DCDC_CONF: u32 = 1610614688;
pub const WDEV_RAND: u32 = 1072827972;
pub const CACHE_FLASH_CTRL_REG: u32 = 1072693260;
pub const CACHE_READ_EN_BIT: u32 = 256;
pub const ESP_CACHE1_ADDR_MAX: u32 = 1048576;
pub const ESP_CACHE2_ADDR_MAX: u32 = 2097152;
pub const DRAM_BASE: u32 = 1073643520;
pub const DRAM_SIZE: u32 = 98304;
pub const IRAM_BASE: u32 = 1074790400;
pub const IRAM_SIZE: u32 = 49152;
pub const FLASH_BASE: u32 = 1075838976;
pub const FLASH_SIZE: u32 = 1048576;
pub const RTC_SYS_BASE: u32 = 1610616832;
pub const RTC_SYS_SIZE: u32 = 512;
pub const RTC_USER_BASE: u32 = 1610617344;
pub const RTC_USER_SIZE: u32 = 512;
pub const ROM_BASE: u32 = 1073741824;
pub const ROM_SIZE: u32 = 65536;
pub const ETS_SLC_INUM: u32 = 1;
pub const ETS_SPI_INUM: u32 = 2;
pub const ETS_GPIO_INUM: u32 = 4;
pub const ETS_UART_INUM: u32 = 5;
pub const ETS_MAX_INUM: u32 = 6;
pub const ETS_SOFT_INUM: u32 = 7;
pub const ETS_WDT_INUM: u32 = 8;
pub const ETS_FRC_TIMER1_INUM: u32 = 9;
pub const ETS_INT_MAX: u32 = 14;
pub const MACSTR: &'static [u8; 30usize] = b"%02x:%02x:%02x:%02x:%02x:%02x\0";
pub const portNUM_PROCESSORS: u32 = 1;
pub const configUSE_PREEMPTION: u32 = 1;
pub const configUSE_IDLE_HOOK: u32 = 1;
pub const configUSE_TICK_HOOK: u32 = 1;
pub const configUSE_TICKLESS_IDLE: u32 = 1;
pub const configMAX_PRIORITIES: u32 = 15;
pub const configMAX_TASK_NAME_LEN: u32 = 16;
pub const configUSE_16_BIT_TICKS: u32 = 0;
pub const configIDLE_SHOULD_YIELD: u32 = 1;
pub const INCLUDE_xTaskGetIdleTaskHandle: u32 = 1;
pub const INCLUDE_xTimerGetTimerDaemonTaskHandle: u32 = 1;
pub const configUSE_MUTEXES: u32 = 1;
pub const configUSE_RECURSIVE_MUTEXES: u32 = 1;
pub const configUSE_COUNTING_SEMAPHORES: u32 = 1;
pub const configUSE_TIMERS: u32 = 1;
pub const configTIMER_QUEUE_LENGTH: u32 = 10;
pub const INCLUDE_xTimerPendFunctionCall: u32 = 1;
pub const configUSE_CO_ROUTINES: u32 = 0;
pub const configMAX_CO_ROUTINE_PRIORITIES: u32 = 2;
pub const INCLUDE_vTaskPrioritySet: u32 = 1;
pub const INCLUDE_uxTaskPriorityGet: u32 = 1;
pub const INCLUDE_vTaskDelete: u32 = 1;
pub const INCLUDE_vTaskCleanUpResources: u32 = 0;
pub const INCLUDE_vTaskSuspend: u32 = 1;
pub const INCLUDE_vTaskDelayUntil: u32 = 1;
pub const INCLUDE_vTaskDelay: u32 = 1;
pub const INCLUDE_xTaskGetCurrentTaskHandle: u32 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark: u32 = 1;
pub const INCLUDE_xSemaphoreGetMutexHolder: u32 = 1;
pub const configKERNEL_INTERRUPT_PRIORITY: u32 = 255;
pub const configMAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 191;
pub const configLIBRARY_KERNEL_INTERRUPT_PRIORITY: u32 = 15;
pub const configNUM_THREAD_LOCAL_STORAGE_POINTERS: u32 = 3;
pub const configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS: u32 = 1;
pub const configRECORD_STACK_HIGH_ADDRESS: u32 = 1;
pub const configIDLE_TASK_STACK_SIZE: u32 = 1024;
pub const configENABLE_TASK_SNAPSHOT: u32 = 1;
pub const configENABLE_TASK_MODIFY_STACK_DEPTH: u32 = 1;
pub const errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: i32 = -1;
pub const errQUEUE_BLOCKED: i32 = -4;
pub const errQUEUE_YIELD: i32 = -5;
pub const configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES: u32 = 0;
pub const pdINTEGRITY_CHECK_VALUE: u32 = 1515870810;
pub const pdFREERTOS_ERRNO_NONE: u32 = 0;
pub const pdFREERTOS_ERRNO_ENOENT: u32 = 2;
pub const pdFREERTOS_ERRNO_EINTR: u32 = 4;
pub const pdFREERTOS_ERRNO_EIO: u32 = 5;
pub const pdFREERTOS_ERRNO_ENXIO: u32 = 6;
pub const pdFREERTOS_ERRNO_EBADF: u32 = 9;
pub const pdFREERTOS_ERRNO_EAGAIN: u32 = 11;
pub const pdFREERTOS_ERRNO_EWOULDBLOCK: u32 = 11;
pub const pdFREERTOS_ERRNO_ENOMEM: u32 = 12;
pub const pdFREERTOS_ERRNO_EACCES: u32 = 13;
pub const pdFREERTOS_ERRNO_EFAULT: u32 = 14;
pub const pdFREERTOS_ERRNO_EBUSY: u32 = 16;
pub const pdFREERTOS_ERRNO_EEXIST: u32 = 17;
pub const pdFREERTOS_ERRNO_EXDEV: u32 = 18;
pub const pdFREERTOS_ERRNO_ENODEV: u32 = 19;
pub const pdFREERTOS_ERRNO_ENOTDIR: u32 = 20;
pub const pdFREERTOS_ERRNO_EISDIR: u32 = 21;
pub const pdFREERTOS_ERRNO_EINVAL: u32 = 22;
pub const pdFREERTOS_ERRNO_ENOSPC: u32 = 28;
pub const pdFREERTOS_ERRNO_ESPIPE: u32 = 29;
pub const pdFREERTOS_ERRNO_EROFS: u32 = 30;
pub const pdFREERTOS_ERRNO_EUNATCH: u32 = 42;
pub const pdFREERTOS_ERRNO_EBADE: u32 = 50;
pub const pdFREERTOS_ERRNO_EFTYPE: u32 = 79;
pub const pdFREERTOS_ERRNO_ENMFILE: u32 = 89;
pub const pdFREERTOS_ERRNO_ENOTEMPTY: u32 = 90;
pub const pdFREERTOS_ERRNO_ENAMETOOLONG: u32 = 91;
pub const pdFREERTOS_ERRNO_EOPNOTSUPP: u32 = 95;
pub const pdFREERTOS_ERRNO_ENOBUFS: u32 = 105;
pub const pdFREERTOS_ERRNO_ENOPROTOOPT: u32 = 109;
pub const pdFREERTOS_ERRNO_EADDRINUSE: u32 = 112;
pub const pdFREERTOS_ERRNO_ETIMEDOUT: u32 = 116;
pub const pdFREERTOS_ERRNO_EINPROGRESS: u32 = 119;
pub const pdFREERTOS_ERRNO_EALREADY: u32 = 120;
pub const pdFREERTOS_ERRNO_EADDRNOTAVAIL: u32 = 125;
pub const pdFREERTOS_ERRNO_EISCONN: u32 = 127;
pub const pdFREERTOS_ERRNO_ENOTCONN: u32 = 128;
pub const pdFREERTOS_ERRNO_ENOMEDIUM: u32 = 135;
pub const pdFREERTOS_ERRNO_EILSEQ: u32 = 138;
pub const pdFREERTOS_ERRNO_ECANCELED: u32 = 140;
pub const pdFREERTOS_LITTLE_ENDIAN: u32 = 0;
pub const pdFREERTOS_BIG_ENDIAN: u32 = 1;
pub const pdLITTLE_ENDIAN: u32 = 0;
pub const pdBIG_ENDIAN: u32 = 1;
pub const XTHAL_RELEASE_MAJOR: u32 = 8000;
pub const XTHAL_RELEASE_MINOR: u32 = 1;
pub const XTHAL_RELEASE_NAME: &'static [u8; 6usize] = b"8.0.1\0";
pub const XTHAL_REL_8: u32 = 1;
pub const XTHAL_REL_8_0: u32 = 1;
pub const XTHAL_REL_8_0_1: u32 = 1;
pub const XTHAL_MAJOR_REV: u32 = 8000;
pub const XTHAL_MINOR_REV: u32 = 1;
pub const XTHAL_MAYBE: i32 = -1;
pub const XTHAL_MAX_CPS: u32 = 8;
pub const XTHAL_LITTLEENDIAN: u32 = 0;
pub const XTHAL_BIGENDIAN: u32 = 1;
pub const XTHAL_PREFETCH_ENABLE: i32 = -1;
pub const XTHAL_PREFETCH_DISABLE: u32 = 0;
pub const XTHAL_DISASM_BUFSIZE: u32 = 80;
pub const XTHAL_DISASM_OPT_ADDR: u32 = 1;
pub const XTHAL_DISASM_OPT_OPHEX: u32 = 2;
pub const XTHAL_DISASM_OPT_OPCODE: u32 = 4;
pub const XTHAL_DISASM_OPT_PARMS: u32 = 8;
pub const XTHAL_DISASM_OPT_ALL: u32 = 4095;
pub const XTHAL_MAX_INTERRUPTS: u32 = 32;
pub const XTHAL_MAX_INTLEVELS: u32 = 16;
pub const XTHAL_MAX_TIMERS: u32 = 4;
pub const XTHAL_INTTYPE_UNCONFIGURED: u32 = 0;
pub const XTHAL_INTTYPE_SOFTWARE: u32 = 1;
pub const XTHAL_INTTYPE_EXTERN_EDGE: u32 = 2;
pub const XTHAL_INTTYPE_EXTERN_LEVEL: u32 = 3;
pub const XTHAL_INTTYPE_TIMER: u32 = 4;
pub const XTHAL_INTTYPE_NMI: u32 = 5;
pub const XTHAL_INTTYPE_WRITE_ERROR: u32 = 6;
pub const XTHAL_MAX_INTTYPES: u32 = 7;
pub const XTHAL_TIMER_UNCONFIGURED: i32 = -1;
pub const XTHAL_TIMER_UNASSIGNED: i32 = -1;
pub const XTHAL_MEMEP_PARITY: u32 = 1;
pub const XTHAL_MEMEP_ECC: u32 = 2;
pub const XTHAL_MEMEP_F_LOCAL: u32 = 0;
pub const XTHAL_MEMEP_F_DCACHE_DATA: u32 = 4;
pub const XTHAL_MEMEP_F_DCACHE_TAG: u32 = 5;
pub const XTHAL_MEMEP_F_ICACHE_DATA: u32 = 6;
pub const XTHAL_MEMEP_F_ICACHE_TAG: u32 = 7;
pub const XTHAL_MEMEP_F_CORRECTABLE: u32 = 16;
pub const XTHAL_AMB_EXCEPTION: u32 = 0;
pub const XTHAL_AMB_HITCACHE: u32 = 1;
pub const XTHAL_AMB_ALLOCATE: u32 = 2;
pub const XTHAL_AMB_WRITETHRU: u32 = 3;
pub const XTHAL_AMB_ISOLATE: u32 = 4;
pub const XTHAL_AMB_GUARD: u32 = 5;
pub const XTHAL_AMB_COHERENT: u32 = 6;
pub const XTHAL_AM_EXCEPTION: u32 = 1;
pub const XTHAL_AM_HITCACHE: u32 = 2;
pub const XTHAL_AM_ALLOCATE: u32 = 4;
pub const XTHAL_AM_WRITETHRU: u32 = 8;
pub const XTHAL_AM_ISOLATE: u32 = 16;
pub const XTHAL_AM_GUARD: u32 = 32;
pub const XTHAL_AM_COHERENT: u32 = 64;
pub const XTHAL_FAM_EXCEPTION: u32 = 1;
pub const XTHAL_FAM_BYPASS: u32 = 0;
pub const XTHAL_FAM_CACHED: u32 = 6;
pub const XTHAL_LAM_EXCEPTION: u32 = 1;
pub const XTHAL_LAM_ISOLATE: u32 = 18;
pub const XTHAL_LAM_BYPASS: u32 = 0;
pub const XTHAL_LAM_BYPASSG: u32 = 32;
pub const XTHAL_LAM_CACHED_NOALLOC: u32 = 2;
pub const XTHAL_LAM_NACACHED: u32 = 2;
pub const XTHAL_LAM_NACACHEDG: u32 = 34;
pub const XTHAL_LAM_CACHED: u32 = 6;
pub const XTHAL_LAM_COHCACHED: u32 = 70;
pub const XTHAL_SAM_EXCEPTION: u32 = 1;
pub const XTHAL_SAM_ISOLATE: u32 = 50;
pub const XTHAL_SAM_BYPASS: u32 = 40;
pub const XTHAL_SAM_WRITETHRU: u32 = 42;
pub const XTHAL_SAM_WRITEBACK: u32 = 38;
pub const XTHAL_SAM_COHWRITEBACK: u32 = 102;
pub const XTHAL_SAM_WRITEBACK_NOALLOC: u32 = 34;
pub const XTHAL_CAFLAG_EXPAND: u32 = 256;
pub const XTHAL_CAFLAG_EXACT: u32 = 512;
pub const XTHAL_CAFLAG_NO_PARTIAL: u32 = 1024;
pub const XTHAL_CAFLAG_NO_AUTO_WB: u32 = 2048;
pub const XTHAL_CAFLAG_NO_AUTO_INV: u32 = 4096;
pub const XCHAL_HAVE_BE: u32 = 0;
pub const XCHAL_HAVE_WINDOWED: u32 = 0;
pub const XCHAL_NUM_AREGS: u32 = 16;
pub const XCHAL_NUM_AREGS_LOG2: u32 = 4;
pub const XCHAL_MAX_INSTRUCTION_SIZE: u32 = 3;
pub const XCHAL_HAVE_DEBUG: u32 = 1;
pub const XCHAL_HAVE_DENSITY: u32 = 1;
pub const XCHAL_HAVE_LOOPS: u32 = 0;
pub const XCHAL_HAVE_NSA: u32 = 1;
pub const XCHAL_HAVE_MINMAX: u32 = 0;
pub const XCHAL_HAVE_SEXT: u32 = 0;
pub const XCHAL_HAVE_CLAMPS: u32 = 0;
pub const XCHAL_HAVE_MUL16: u32 = 1;
pub const XCHAL_HAVE_MUL32: u32 = 1;
pub const XCHAL_HAVE_MUL32_HIGH: u32 = 0;
pub const XCHAL_HAVE_DIV32: u32 = 0;
pub const XCHAL_HAVE_L32R: u32 = 1;
pub const XCHAL_HAVE_ABSOLUTE_LITERALS: u32 = 1;
pub const XCHAL_HAVE_CONST16: u32 = 0;
pub const XCHAL_HAVE_ADDX: u32 = 1;
pub const XCHAL_HAVE_WIDE_BRANCHES: u32 = 0;
pub const XCHAL_HAVE_PREDICTED_BRANCHES: u32 = 0;
pub const XCHAL_HAVE_CALL4AND12: u32 = 0;
pub const XCHAL_HAVE_ABS: u32 = 1;
pub const XCHAL_HAVE_RELEASE_SYNC: u32 = 0;
pub const XCHAL_HAVE_S32C1I: u32 = 0;
pub const XCHAL_HAVE_SPECULATION: u32 = 0;
pub const XCHAL_HAVE_FULL_RESET: u32 = 1;
pub const XCHAL_NUM_CONTEXTS: u32 = 1;
pub const XCHAL_NUM_MISC_REGS: u32 = 0;
pub const XCHAL_HAVE_TAP_MASTER: u32 = 0;
pub const XCHAL_HAVE_PRID: u32 = 1;
pub const XCHAL_HAVE_EXTERN_REGS: u32 = 1;
pub const XCHAL_HAVE_MP_INTERRUPTS: u32 = 0;
pub const XCHAL_HAVE_MP_RUNSTALL: u32 = 0;
pub const XCHAL_HAVE_THREADPTR: u32 = 0;
pub const XCHAL_HAVE_BOOLEANS: u32 = 0;
pub const XCHAL_HAVE_CP: u32 = 0;
pub const XCHAL_CP_MAXCFG: u32 = 0;
pub const XCHAL_HAVE_MAC16: u32 = 0;
pub const XCHAL_HAVE_VECTORFPU2005: u32 = 0;
pub const XCHAL_HAVE_FP: u32 = 0;
pub const XCHAL_HAVE_DFP: u32 = 0;
pub const XCHAL_HAVE_DFP_accel: u32 = 0;
pub const XCHAL_HAVE_VECTRA1: u32 = 0;
pub const XCHAL_HAVE_VECTRALX: u32 = 0;
pub const XCHAL_HAVE_HIFIPRO: u32 = 0;
pub const XCHAL_HAVE_HIFI2: u32 = 0;
pub const XCHAL_HAVE_CONNXD2: u32 = 0;
pub const XCHAL_NUM_WRITEBUFFER_ENTRIES: u32 = 1;
pub const XCHAL_INST_FETCH_WIDTH: u32 = 4;
pub const XCHAL_DATA_WIDTH: u32 = 4;
pub const XCHAL_UNALIGNED_LOAD_EXCEPTION: u32 = 1;
pub const XCHAL_UNALIGNED_STORE_EXCEPTION: u32 = 1;
pub const XCHAL_UNALIGNED_LOAD_HW: u32 = 0;
pub const XCHAL_UNALIGNED_STORE_HW: u32 = 0;
pub const XCHAL_SW_VERSION: u32 = 800001;
pub const XCHAL_CORE_ID: &'static [u8; 6usize] = b"lx106\0";
pub const XCHAL_BUILD_UNIQUE_ID: u32 = 177910;
pub const XCHAL_HW_CONFIGID0: u32 = 3264011002;
pub const XCHAL_HW_CONFIGID1: u32 = 277001974;
pub const XCHAL_HW_VERSION_NAME: &'static [u8; 8usize] = b"LX3.0.1\0";
pub const XCHAL_HW_VERSION_MAJOR: u32 = 2300;
pub const XCHAL_HW_VERSION_MINOR: u32 = 1;
pub const XCHAL_HW_VERSION: u32 = 230001;
pub const XCHAL_HW_REL_LX3: u32 = 1;
pub const XCHAL_HW_REL_LX3_0: u32 = 1;
pub const XCHAL_HW_REL_LX3_0_1: u32 = 1;
pub const XCHAL_HW_CONFIGID_RELIABLE: u32 = 1;
pub const XCHAL_HW_MIN_VERSION_MAJOR: u32 = 2300;
pub const XCHAL_HW_MIN_VERSION_MINOR: u32 = 1;
pub const XCHAL_HW_MIN_VERSION: u32 = 230001;
pub const XCHAL_HW_MAX_VERSION_MAJOR: u32 = 2300;
pub const XCHAL_HW_MAX_VERSION_MINOR: u32 = 1;
pub const XCHAL_HW_MAX_VERSION: u32 = 230001;
pub const XCHAL_ICACHE_LINESIZE: u32 = 4;
pub const XCHAL_DCACHE_LINESIZE: u32 = 4;
pub const XCHAL_ICACHE_LINEWIDTH: u32 = 2;
pub const XCHAL_DCACHE_LINEWIDTH: u32 = 2;
pub const XCHAL_ICACHE_SIZE: u32 = 0;
pub const XCHAL_DCACHE_SIZE: u32 = 0;
pub const XCHAL_DCACHE_IS_WRITEBACK: u32 = 0;
pub const XCHAL_DCACHE_IS_COHERENT: u32 = 0;
pub const XCHAL_HAVE_PREFETCH: u32 = 0;
pub const XCHAL_HAVE_PIF: u32 = 1;
pub const XCHAL_ICACHE_SETWIDTH: u32 = 0;
pub const XCHAL_DCACHE_SETWIDTH: u32 = 0;
pub const XCHAL_ICACHE_WAYS: u32 = 1;
pub const XCHAL_DCACHE_WAYS: u32 = 1;
pub const XCHAL_ICACHE_LINE_LOCKABLE: u32 = 0;
pub const XCHAL_DCACHE_LINE_LOCKABLE: u32 = 0;
pub const XCHAL_ICACHE_ECC_PARITY: u32 = 0;
pub const XCHAL_DCACHE_ECC_PARITY: u32 = 0;
pub const XCHAL_ICACHE_ACCESS_SIZE: u32 = 1;
pub const XCHAL_DCACHE_ACCESS_SIZE: u32 = 1;
pub const XCHAL_CA_BITS: u32 = 4;
pub const XCHAL_NUM_INSTROM: u32 = 1;
pub const XCHAL_NUM_INSTRAM: u32 = 2;
pub const XCHAL_NUM_DATAROM: u32 = 1;
pub const XCHAL_NUM_DATARAM: u32 = 2;
pub const XCHAL_NUM_URAM: u32 = 0;
pub const XCHAL_NUM_XLMI: u32 = 1;
pub const XCHAL_INSTROM0_VADDR: u32 = 1075838976;
pub const XCHAL_INSTROM0_PADDR: u32 = 1075838976;
pub const XCHAL_INSTROM0_SIZE: u32 = 1048576;
pub const XCHAL_INSTROM0_ECC_PARITY: u32 = 0;
pub const XCHAL_INSTRAM0_VADDR: u32 = 1073741824;
pub const XCHAL_INSTRAM0_PADDR: u32 = 1073741824;
pub const XCHAL_INSTRAM0_SIZE: u32 = 1048576;
pub const XCHAL_INSTRAM0_ECC_PARITY: u32 = 0;
pub const XCHAL_INSTRAM1_VADDR: u32 = 1074790400;
pub const XCHAL_INSTRAM1_PADDR: u32 = 1074790400;
pub const XCHAL_INSTRAM1_SIZE: u32 = 1048576;
pub const XCHAL_INSTRAM1_ECC_PARITY: u32 = 0;
pub const XCHAL_DATAROM0_VADDR: u32 = 1072955392;
pub const XCHAL_DATAROM0_PADDR: u32 = 1072955392;
pub const XCHAL_DATAROM0_SIZE: u32 = 262144;
pub const XCHAL_DATAROM0_ECC_PARITY: u32 = 0;
pub const XCHAL_DATARAM0_VADDR: u32 = 1073479680;
pub const XCHAL_DATARAM0_PADDR: u32 = 1073479680;
pub const XCHAL_DATARAM0_SIZE: u32 = 262144;
pub const XCHAL_DATARAM0_ECC_PARITY: u32 = 0;
pub const XCHAL_DATARAM1_VADDR: u32 = 1073217536;
pub const XCHAL_DATARAM1_PADDR: u32 = 1073217536;
pub const XCHAL_DATARAM1_SIZE: u32 = 262144;
pub const XCHAL_DATARAM1_ECC_PARITY: u32 = 0;
pub const XCHAL_XLMI0_VADDR: u32 = 1072693248;
pub const XCHAL_XLMI0_PADDR: u32 = 1072693248;
pub const XCHAL_XLMI0_SIZE: u32 = 262144;
pub const XCHAL_XLMI0_ECC_PARITY: u32 = 0;
pub const XCHAL_HAVE_INTERRUPTS: u32 = 1;
pub const XCHAL_HAVE_HIGHPRI_INTERRUPTS: u32 = 1;
pub const XCHAL_HAVE_NMI: u32 = 1;
pub const XCHAL_HAVE_CCOUNT: u32 = 1;
pub const XCHAL_NUM_TIMERS: u32 = 1;
pub const XCHAL_NUM_INTERRUPTS: u32 = 15;
pub const XCHAL_NUM_INTERRUPTS_LOG2: u32 = 4;
pub const XCHAL_NUM_EXTINTERRUPTS: u32 = 13;
pub const XCHAL_NUM_INTLEVELS: u32 = 2;
pub const XCHAL_EXCM_LEVEL: u32 = 1;
pub const XCHAL_INTLEVEL1_MASK: u32 = 16383;
pub const XCHAL_INTLEVEL2_MASK: u32 = 0;
pub const XCHAL_INTLEVEL3_MASK: u32 = 16384;
pub const XCHAL_INTLEVEL4_MASK: u32 = 0;
pub const XCHAL_INTLEVEL5_MASK: u32 = 0;
pub const XCHAL_INTLEVEL6_MASK: u32 = 0;
pub const XCHAL_INTLEVEL7_MASK: u32 = 0;
pub const XCHAL_INTLEVEL1_ANDBELOW_MASK: u32 = 16383;
pub const XCHAL_INTLEVEL2_ANDBELOW_MASK: u32 = 16383;
pub const XCHAL_INTLEVEL3_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL4_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL5_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL6_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL7_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INT0_LEVEL: u32 = 1;
pub const XCHAL_INT1_LEVEL: u32 = 1;
pub const XCHAL_INT2_LEVEL: u32 = 1;
pub const XCHAL_INT3_LEVEL: u32 = 1;
pub const XCHAL_INT4_LEVEL: u32 = 1;
pub const XCHAL_INT5_LEVEL: u32 = 1;
pub const XCHAL_INT6_LEVEL: u32 = 1;
pub const XCHAL_INT7_LEVEL: u32 = 1;
pub const XCHAL_INT8_LEVEL: u32 = 1;
pub const XCHAL_INT9_LEVEL: u32 = 1;
pub const XCHAL_INT10_LEVEL: u32 = 1;
pub const XCHAL_INT11_LEVEL: u32 = 1;
pub const XCHAL_INT12_LEVEL: u32 = 1;
pub const XCHAL_INT13_LEVEL: u32 = 1;
pub const XCHAL_INT14_LEVEL: u32 = 3;
pub const XCHAL_DEBUGLEVEL: u32 = 2;
pub const XCHAL_HAVE_DEBUG_EXTERN_INT: u32 = 1;
pub const XCHAL_NMILEVEL: u32 = 3;
pub const XCHAL_INT0_TYPE: u32 = 3;
pub const XCHAL_INT1_TYPE: u32 = 3;
pub const XCHAL_INT2_TYPE: u32 = 3;
pub const XCHAL_INT3_TYPE: u32 = 3;
pub const XCHAL_INT4_TYPE: u32 = 3;
pub const XCHAL_INT5_TYPE: u32 = 3;
pub const XCHAL_INT6_TYPE: u32 = 4;
pub const XCHAL_INT7_TYPE: u32 = 1;
pub const XCHAL_INT8_TYPE: u32 = 2;
pub const XCHAL_INT9_TYPE: u32 = 2;
pub const XCHAL_INT10_TYPE: u32 = 2;
pub const XCHAL_INT11_TYPE: u32 = 2;
pub const XCHAL_INT12_TYPE: u32 = 2;
pub const XCHAL_INT13_TYPE: u32 = 2;
pub const XCHAL_INT14_TYPE: u32 = 5;
pub const XCHAL_INTTYPE_MASK_UNCONFIGURED: u32 = 4294934528;
pub const XCHAL_INTTYPE_MASK_SOFTWARE: u32 = 128;
pub const XCHAL_INTTYPE_MASK_EXTERN_EDGE: u32 = 16128;
pub const XCHAL_INTTYPE_MASK_EXTERN_LEVEL: u32 = 63;
pub const XCHAL_INTTYPE_MASK_TIMER: u32 = 64;
pub const XCHAL_INTTYPE_MASK_NMI: u32 = 16384;
pub const XCHAL_INTTYPE_MASK_WRITE_ERROR: u32 = 0;
pub const XCHAL_TIMER0_INTERRUPT: u32 = 6;
pub const XCHAL_TIMER1_INTERRUPT: i32 = -1;
pub const XCHAL_TIMER2_INTERRUPT: i32 = -1;
pub const XCHAL_TIMER3_INTERRUPT: i32 = -1;
pub const XCHAL_NMI_INTERRUPT: u32 = 14;
pub const XCHAL_INTLEVEL3_NUM: u32 = 14;
pub const XCHAL_EXTINT0_NUM: u32 = 0;
pub const XCHAL_EXTINT1_NUM: u32 = 1;
pub const XCHAL_EXTINT2_NUM: u32 = 2;
pub const XCHAL_EXTINT3_NUM: u32 = 3;
pub const XCHAL_EXTINT4_NUM: u32 = 4;
pub const XCHAL_EXTINT5_NUM: u32 = 5;
pub const XCHAL_EXTINT6_NUM: u32 = 8;
pub const XCHAL_EXTINT7_NUM: u32 = 9;
pub const XCHAL_EXTINT8_NUM: u32 = 10;
pub const XCHAL_EXTINT9_NUM: u32 = 11;
pub const XCHAL_EXTINT10_NUM: u32 = 12;
pub const XCHAL_EXTINT11_NUM: u32 = 13;
pub const XCHAL_EXTINT12_NUM: u32 = 14;
pub const XCHAL_XEA_VERSION: u32 = 2;
pub const XCHAL_HAVE_XEA1: u32 = 0;
pub const XCHAL_HAVE_XEA2: u32 = 1;
pub const XCHAL_HAVE_XEAX: u32 = 0;
pub const XCHAL_HAVE_EXCEPTIONS: u32 = 1;
pub const XCHAL_HAVE_MEM_ECC_PARITY: u32 = 0;
pub const XCHAL_HAVE_VECTOR_SELECT: u32 = 1;
pub const XCHAL_HAVE_VECBASE: u32 = 1;
pub const XCHAL_VECBASE_RESET_VADDR: u32 = 1073741824;
pub const XCHAL_VECBASE_RESET_PADDR: u32 = 1073741824;
pub const XCHAL_RESET_VECBASE_OVERLAP: u32 = 0;
pub const XCHAL_RESET_VECTOR0_VADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR0_PADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR1_VADDR: u32 = 1073741952;
pub const XCHAL_RESET_VECTOR1_PADDR: u32 = 1073741952;
pub const XCHAL_RESET_VECTOR_VADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR_PADDR: u32 = 1342177280;
pub const XCHAL_USER_VECOFS: u32 = 80;
pub const XCHAL_USER_VECTOR_VADDR: u32 = 1073741904;
pub const XCHAL_USER_VECTOR_PADDR: u32 = 1073741904;
pub const XCHAL_KERNEL_VECOFS: u32 = 48;
pub const XCHAL_KERNEL_VECTOR_VADDR: u32 = 1073741872;
pub const XCHAL_KERNEL_VECTOR_PADDR: u32 = 1073741872;
pub const XCHAL_DOUBLEEXC_VECOFS: u32 = 112;
pub const XCHAL_DOUBLEEXC_VECTOR_VADDR: u32 = 1073741936;
pub const XCHAL_DOUBLEEXC_VECTOR_PADDR: u32 = 1073741936;
pub const XCHAL_INTLEVEL2_VECOFS: u32 = 16;
pub const XCHAL_INTLEVEL2_VECTOR_VADDR: u32 = 1073741840;
pub const XCHAL_INTLEVEL2_VECTOR_PADDR: u32 = 1073741840;
pub const XCHAL_DEBUG_VECOFS: u32 = 16;
pub const XCHAL_DEBUG_VECTOR_VADDR: u32 = 1073741840;
pub const XCHAL_DEBUG_VECTOR_PADDR: u32 = 1073741840;
pub const XCHAL_NMI_VECOFS: u32 = 32;
pub const XCHAL_NMI_VECTOR_VADDR: u32 = 1073741856;
pub const XCHAL_NMI_VECTOR_PADDR: u32 = 1073741856;
pub const XCHAL_INTLEVEL3_VECOFS: u32 = 32;
pub const XCHAL_INTLEVEL3_VECTOR_VADDR: u32 = 1073741856;
pub const XCHAL_INTLEVEL3_VECTOR_PADDR: u32 = 1073741856;
pub const XCHAL_HAVE_OCD: u32 = 1;
pub const XCHAL_NUM_IBREAK: u32 = 1;
pub const XCHAL_NUM_DBREAK: u32 = 1;
pub const XCHAL_HAVE_OCD_DIR_ARRAY: u32 = 0;
pub const XCHAL_HAVE_TLBS: u32 = 1;
pub const XCHAL_HAVE_SPANNING_WAY: u32 = 1;
pub const XCHAL_SPANNING_WAY: u32 = 0;
pub const XCHAL_HAVE_IDENTITY_MAP: u32 = 1;
pub const XCHAL_HAVE_CACHEATTR: u32 = 0;
pub const XCHAL_HAVE_MIMIC_CACHEATTR: u32 = 1;
pub const XCHAL_HAVE_XLT_CACHEATTR: u32 = 0;
pub const XCHAL_HAVE_PTP_MMU: u32 = 0;
pub const XCHAL_MMU_ASID_BITS: u32 = 0;
pub const XCHAL_MMU_RINGS: u32 = 1;
pub const XCHAL_MMU_RING_BITS: u32 = 0;
pub const XCHAL_CA_BYPASS: u32 = 2;
pub const XCHAL_CA_WRITETHRU: u32 = 2;
pub const XCHAL_CA_WRITEBACK: u32 = 2;
pub const XCHAL_CA_WRITEBACK_NOALLOC: u32 = 2;
pub const XCHAL_CA_BYPASS_RW: u32 = 0;
pub const XCHAL_CA_WRITETHRU_RW: u32 = 0;
pub const XCHAL_CA_WRITEBACK_RW: u32 = 0;
pub const XCHAL_CA_WRITEBACK_NOALLOC_RW: u32 = 0;
pub const XCHAL_CA_ILLEGAL: u32 = 15;
pub const XCHAL_CA_ISOLATE: u32 = 0;
pub const XCHAL_MMU_ASID_INVALID: u32 = 0;
pub const XCHAL_MMU_ASID_KERNEL: u32 = 0;
pub const XCHAL_MMU_SR_BITS: u32 = 0;
pub const XCHAL_MMU_CA_BITS: u32 = 4;
pub const XCHAL_MMU_MAX_PTE_PAGE_SIZE: u32 = 29;
pub const XCHAL_MMU_MIN_PTE_PAGE_SIZE: u32 = 29;
pub const XCHAL_ITLB_WAY_BITS: u32 = 0;
pub const XCHAL_ITLB_WAYS: u32 = 1;
pub const XCHAL_ITLB_ARF_WAYS: u32 = 0;
pub const XCHAL_ITLB_SETS: u32 = 1;
pub const XCHAL_ITLB_WAY0_SET: u32 = 0;
pub const XCHAL_ITLB_ARF_SETS: u32 = 0;
pub const XCHAL_ITLB_MINWIRED_SETS: u32 = 0;
pub const XCHAL_ITLB_SET0_WAY: u32 = 0;
pub const XCHAL_ITLB_SET0_WAYS: u32 = 1;
pub const XCHAL_ITLB_SET0_ENTRIES_LOG2: u32 = 3;
pub const XCHAL_ITLB_SET0_ENTRIES: u32 = 8;
pub const XCHAL_ITLB_SET0_ARF: u32 = 0;
pub const XCHAL_ITLB_SET0_PAGESIZES: u32 = 1;
pub const XCHAL_ITLB_SET0_PAGESZ_BITS: u32 = 0;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_MIN: u32 = 29;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_MAX: u32 = 29;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_LIST: u32 = 29;
pub const XCHAL_ITLB_SET0_ASID_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_VPN_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_PPN_CONSTMASK: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_CA_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_ASID_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_VPN_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_PPN_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_CA_RESET: u32 = 1;
pub const XCHAL_ITLB_SET0_E0_VPN_CONST: u32 = 0;
pub const XCHAL_ITLB_SET0_E1_VPN_CONST: u32 = 536870912;
pub const XCHAL_ITLB_SET0_E2_VPN_CONST: u32 = 1073741824;
pub const XCHAL_ITLB_SET0_E3_VPN_CONST: u32 = 1610612736;
pub const XCHAL_ITLB_SET0_E4_VPN_CONST: u32 = 2147483648;
pub const XCHAL_ITLB_SET0_E5_VPN_CONST: u32 = 2684354560;
pub const XCHAL_ITLB_SET0_E6_VPN_CONST: u32 = 3221225472;
pub const XCHAL_ITLB_SET0_E7_VPN_CONST: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_E0_PPN_CONST: u32 = 0;
pub const XCHAL_ITLB_SET0_E1_PPN_CONST: u32 = 536870912;
pub const XCHAL_ITLB_SET0_E2_PPN_CONST: u32 = 1073741824;
pub const XCHAL_ITLB_SET0_E3_PPN_CONST: u32 = 1610612736;
pub const XCHAL_ITLB_SET0_E4_PPN_CONST: u32 = 2147483648;
pub const XCHAL_ITLB_SET0_E5_PPN_CONST: u32 = 2684354560;
pub const XCHAL_ITLB_SET0_E6_PPN_CONST: u32 = 3221225472;
pub const XCHAL_ITLB_SET0_E7_PPN_CONST: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_E0_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E1_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E2_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E3_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E4_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E5_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E6_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E7_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_WAY_BITS: u32 = 0;
pub const XCHAL_DTLB_WAYS: u32 = 1;
pub const XCHAL_DTLB_ARF_WAYS: u32 = 0;
pub const XCHAL_DTLB_SETS: u32 = 1;
pub const XCHAL_DTLB_WAY0_SET: u32 = 0;
pub const XCHAL_DTLB_ARF_SETS: u32 = 0;
pub const XCHAL_DTLB_MINWIRED_SETS: u32 = 0;
pub const XCHAL_DTLB_SET0_WAY: u32 = 0;
pub const XCHAL_DTLB_SET0_WAYS: u32 = 1;
pub const XCHAL_DTLB_SET0_ENTRIES_LOG2: u32 = 3;
pub const XCHAL_DTLB_SET0_ENTRIES: u32 = 8;
pub const XCHAL_DTLB_SET0_ARF: u32 = 0;
pub const XCHAL_DTLB_SET0_PAGESIZES: u32 = 1;
pub const XCHAL_DTLB_SET0_PAGESZ_BITS: u32 = 0;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_MIN: u32 = 29;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_MAX: u32 = 29;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_LIST: u32 = 29;
pub const XCHAL_DTLB_SET0_ASID_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_VPN_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_PPN_CONSTMASK: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_CA_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_ASID_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_VPN_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_PPN_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_CA_RESET: u32 = 1;
pub const XCHAL_DTLB_SET0_E0_VPN_CONST: u32 = 0;
pub const XCHAL_DTLB_SET0_E1_VPN_CONST: u32 = 536870912;
pub const XCHAL_DTLB_SET0_E2_VPN_CONST: u32 = 1073741824;
pub const XCHAL_DTLB_SET0_E3_VPN_CONST: u32 = 1610612736;
pub const XCHAL_DTLB_SET0_E4_VPN_CONST: u32 = 2147483648;
pub const XCHAL_DTLB_SET0_E5_VPN_CONST: u32 = 2684354560;
pub const XCHAL_DTLB_SET0_E6_VPN_CONST: u32 = 3221225472;
pub const XCHAL_DTLB_SET0_E7_VPN_CONST: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_E0_PPN_CONST: u32 = 0;
pub const XCHAL_DTLB_SET0_E1_PPN_CONST: u32 = 536870912;
pub const XCHAL_DTLB_SET0_E2_PPN_CONST: u32 = 1073741824;
pub const XCHAL_DTLB_SET0_E3_PPN_CONST: u32 = 1610612736;
pub const XCHAL_DTLB_SET0_E4_PPN_CONST: u32 = 2147483648;
pub const XCHAL_DTLB_SET0_E5_PPN_CONST: u32 = 2684354560;
pub const XCHAL_DTLB_SET0_E6_PPN_CONST: u32 = 3221225472;
pub const XCHAL_DTLB_SET0_E7_PPN_CONST: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_E0_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E1_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E2_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E3_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E4_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E5_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E6_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E7_CA_RESET: u32 = 2;
pub const XCHAL_CP_NUM: u32 = 0;
pub const XCHAL_CP_MAX: u32 = 0;
pub const XCHAL_CP_MASK: u32 = 0;
pub const XCHAL_CP_PORT_MASK: u32 = 0;
pub const XCHAL_NCP_SA_SIZE: u32 = 0;
pub const XCHAL_NCP_SA_ALIGN: u32 = 1;
pub const XCHAL_TOTAL_SA_SIZE: u32 = 0;
pub const XCHAL_TOTAL_SA_ALIGN: u32 = 1;
pub const XCHAL_NCP_SA_NUM: u32 = 0;
pub const XCHAL_CP0_SA_NUM: u32 = 0;
pub const XCHAL_CP1_SA_NUM: u32 = 0;
pub const XCHAL_CP2_SA_NUM: u32 = 0;
pub const XCHAL_CP3_SA_NUM: u32 = 0;
pub const XCHAL_CP4_SA_NUM: u32 = 0;
pub const XCHAL_CP5_SA_NUM: u32 = 0;
pub const XCHAL_CP6_SA_NUM: u32 = 0;
pub const XCHAL_CP7_SA_NUM: u32 = 0;
pub const XCHAL_HAVE_LE: u32 = 1;
pub const XCHAL_MEMORY_ORDER: u32 = 0;
pub const XCHAL_HAVE_HIGHLEVEL_INTERRUPTS: u32 = 1;
pub const XCHAL_NUM_LOWPRI_LEVELS: u32 = 1;
pub const XCHAL_FIRST_HIGHPRI_LEVEL: u32 = 2;
pub const XCHAL_INTLEVEL0_MASK: u32 = 0;
pub const XCHAL_INTLEVEL8_MASK: u32 = 0;
pub const XCHAL_INTLEVEL9_MASK: u32 = 0;
pub const XCHAL_INTLEVEL10_MASK: u32 = 0;
pub const XCHAL_INTLEVEL11_MASK: u32 = 0;
pub const XCHAL_INTLEVEL12_MASK: u32 = 0;
pub const XCHAL_INTLEVEL13_MASK: u32 = 0;
pub const XCHAL_INTLEVEL14_MASK: u32 = 0;
pub const XCHAL_INTLEVEL15_MASK: u32 = 0;
pub const XCHAL_INTLEVEL0_ANDBELOW_MASK: u32 = 0;
pub const XCHAL_INTLEVEL8_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL9_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL10_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL11_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL12_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL13_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL14_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_INTLEVEL15_ANDBELOW_MASK: u32 = 32767;
pub const XCHAL_LOWPRI_MASK: u32 = 16383;
pub const XCHAL_INTCLEARABLE_MASK: u32 = 16256;
pub const XCHAL_INTSETTABLE_MASK: u32 = 128;
pub const XCHAL_INT15_LEVEL: u32 = 0;
pub const XCHAL_INT15_TYPE: u32 = 0;
pub const XCHAL_INT16_LEVEL: u32 = 0;
pub const XCHAL_INT16_TYPE: u32 = 0;
pub const XCHAL_INT17_LEVEL: u32 = 0;
pub const XCHAL_INT17_TYPE: u32 = 0;
pub const XCHAL_INT18_LEVEL: u32 = 0;
pub const XCHAL_INT18_TYPE: u32 = 0;
pub const XCHAL_INT19_LEVEL: u32 = 0;
pub const XCHAL_INT19_TYPE: u32 = 0;
pub const XCHAL_INT20_LEVEL: u32 = 0;
pub const XCHAL_INT20_TYPE: u32 = 0;
pub const XCHAL_INT21_LEVEL: u32 = 0;
pub const XCHAL_INT21_TYPE: u32 = 0;
pub const XCHAL_INT22_LEVEL: u32 = 0;
pub const XCHAL_INT22_TYPE: u32 = 0;
pub const XCHAL_INT23_LEVEL: u32 = 0;
pub const XCHAL_INT23_TYPE: u32 = 0;
pub const XCHAL_INT24_LEVEL: u32 = 0;
pub const XCHAL_INT24_TYPE: u32 = 0;
pub const XCHAL_INT25_LEVEL: u32 = 0;
pub const XCHAL_INT25_TYPE: u32 = 0;
pub const XCHAL_INT26_LEVEL: u32 = 0;
pub const XCHAL_INT26_TYPE: u32 = 0;
pub const XCHAL_INT27_LEVEL: u32 = 0;
pub const XCHAL_INT27_TYPE: u32 = 0;
pub const XCHAL_INT28_LEVEL: u32 = 0;
pub const XCHAL_INT28_TYPE: u32 = 0;
pub const XCHAL_INT29_LEVEL: u32 = 0;
pub const XCHAL_INT29_TYPE: u32 = 0;
pub const XCHAL_INT30_LEVEL: u32 = 0;
pub const XCHAL_INT30_TYPE: u32 = 0;
pub const XCHAL_INT31_LEVEL: u32 = 0;
pub const XCHAL_INT31_TYPE: u32 = 0;
pub const XCHAL_EXTINT0_MASK: u32 = 1;
pub const XCHAL_EXTINT1_MASK: u32 = 2;
pub const XCHAL_EXTINT2_MASK: u32 = 4;
pub const XCHAL_EXTINT3_MASK: u32 = 8;
pub const XCHAL_EXTINT4_MASK: u32 = 16;
pub const XCHAL_EXTINT5_MASK: u32 = 32;
pub const XCHAL_EXTINT6_MASK: u32 = 256;
pub const XCHAL_EXTINT7_MASK: u32 = 512;
pub const XCHAL_EXTINT8_MASK: u32 = 1024;
pub const XCHAL_EXTINT9_MASK: u32 = 2048;
pub const XCHAL_EXTINT10_MASK: u32 = 4096;
pub const XCHAL_EXTINT11_MASK: u32 = 8192;
pub const XCHAL_EXTINT12_MASK: u32 = 16384;
pub const XCHAL_HAVE_OLD_EXC_ARCH: u32 = 0;
pub const XCHAL_HAVE_EXCM: u32 = 1;
pub const XCHAL_PROGRAMEXC_VECTOR_VADDR: u32 = 1073741904;
pub const XCHAL_USEREXC_VECTOR_VADDR: u32 = 1073741904;
pub const XCHAL_PROGRAMEXC_VECTOR_PADDR: u32 = 1073741904;
pub const XCHAL_USEREXC_VECTOR_PADDR: u32 = 1073741904;
pub const XCHAL_STACKEDEXC_VECTOR_VADDR: u32 = 1073741872;
pub const XCHAL_KERNELEXC_VECTOR_VADDR: u32 = 1073741872;
pub const XCHAL_STACKEDEXC_VECTOR_PADDR: u32 = 1073741872;
pub const XCHAL_KERNELEXC_VECTOR_PADDR: u32 = 1073741872;
pub const XCHAL_EXCCAUSE_ILLEGAL_INSTRUCTION: u32 = 0;
pub const XCHAL_EXCCAUSE_SYSTEM_CALL: u32 = 1;
pub const XCHAL_EXCCAUSE_INSTRUCTION_FETCH_ERROR: u32 = 2;
pub const XCHAL_EXCCAUSE_LOAD_STORE_ERROR: u32 = 3;
pub const XCHAL_EXCCAUSE_LEVEL1_INTERRUPT: u32 = 4;
pub const XCHAL_EXCCAUSE_ALLOCA: u32 = 5;
pub const XCHAL_EXCCAUSE_INTEGER_DIVIDE_BY_ZERO: u32 = 6;
pub const XCHAL_EXCCAUSE_SPECULATION: u32 = 7;
pub const XCHAL_EXCCAUSE_PRIVILEGED: u32 = 8;
pub const XCHAL_EXCCAUSE_UNALIGNED: u32 = 9;
pub const XCHAL_EXCCAUSE_ITLB_MISS: u32 = 16;
pub const XCHAL_EXCCAUSE_ITLB_MULTIHIT: u32 = 17;
pub const XCHAL_EXCCAUSE_ITLB_PRIVILEGE: u32 = 18;
pub const XCHAL_EXCCAUSE_ITLB_SIZE_RESTRICTION: u32 = 19;
pub const XCHAL_EXCCAUSE_FETCH_CACHE_ATTRIBUTE: u32 = 20;
pub const XCHAL_EXCCAUSE_DTLB_MISS: u32 = 24;
pub const XCHAL_EXCCAUSE_DTLB_MULTIHIT: u32 = 25;
pub const XCHAL_EXCCAUSE_DTLB_PRIVILEGE: u32 = 26;
pub const XCHAL_EXCCAUSE_DTLB_SIZE_RESTRICTION: u32 = 27;
pub const XCHAL_EXCCAUSE_LOAD_CACHE_ATTRIBUTE: u32 = 28;
pub const XCHAL_EXCCAUSE_STORE_CACHE_ATTRIBUTE: u32 = 29;
pub const XCHAL_EXCCAUSE_COPROCESSOR0_DISABLED: u32 = 32;
pub const XCHAL_EXCCAUSE_COPROCESSOR1_DISABLED: u32 = 33;
pub const XCHAL_EXCCAUSE_COPROCESSOR2_DISABLED: u32 = 34;
pub const XCHAL_EXCCAUSE_COPROCESSOR3_DISABLED: u32 = 35;
pub const XCHAL_EXCCAUSE_COPROCESSOR4_DISABLED: u32 = 36;
pub const XCHAL_EXCCAUSE_COPROCESSOR5_DISABLED: u32 = 37;
pub const XCHAL_EXCCAUSE_COPROCESSOR6_DISABLED: u32 = 38;
pub const XCHAL_EXCCAUSE_COPROCESSOR7_DISABLED: u32 = 39;
pub const XCHAL_EXCCAUSE_FLOATING_POINT: u32 = 40;
pub const XCHAL_DBREAKC_VALIDMASK: u32 = 3221225535;
pub const XCHAL_DBREAKC_MASK_BITS: u32 = 6;
pub const XCHAL_DBREAKC_MASK_NUM: u32 = 64;
pub const XCHAL_DBREAKC_MASK_SHIFT: u32 = 0;
pub const XCHAL_DBREAKC_MASK_MASK: u32 = 63;
pub const XCHAL_DBREAKC_LOADBREAK_BITS: u32 = 1;
pub const XCHAL_DBREAKC_LOADBREAK_NUM: u32 = 2;
pub const XCHAL_DBREAKC_LOADBREAK_SHIFT: u32 = 30;
pub const XCHAL_DBREAKC_LOADBREAK_MASK: u32 = 1073741824;
pub const XCHAL_DBREAKC_STOREBREAK_BITS: u32 = 1;
pub const XCHAL_DBREAKC_STOREBREAK_NUM: u32 = 2;
pub const XCHAL_DBREAKC_STOREBREAK_SHIFT: u32 = 31;
pub const XCHAL_DBREAKC_STOREBREAK_MASK: u32 = 2147483648;
pub const XCHAL_PS_VALIDMASK: u32 = 462655;
pub const XCHAL_PS_INTLEVEL_BITS: u32 = 4;
pub const XCHAL_PS_INTLEVEL_NUM: u32 = 16;
pub const XCHAL_PS_INTLEVEL_SHIFT: u32 = 0;
pub const XCHAL_PS_INTLEVEL_MASK: u32 = 15;
pub const XCHAL_PS_EXCM_BITS: u32 = 1;
pub const XCHAL_PS_EXCM_NUM: u32 = 2;
pub const XCHAL_PS_EXCM_SHIFT: u32 = 4;
pub const XCHAL_PS_EXCM_MASK: u32 = 16;
pub const XCHAL_PS_UM_BITS: u32 = 1;
pub const XCHAL_PS_UM_NUM: u32 = 2;
pub const XCHAL_PS_UM_SHIFT: u32 = 5;
pub const XCHAL_PS_UM_MASK: u32 = 32;
pub const XCHAL_PS_RING_BITS: u32 = 2;
pub const XCHAL_PS_RING_NUM: u32 = 4;
pub const XCHAL_PS_RING_SHIFT: u32 = 6;
pub const XCHAL_PS_RING_MASK: u32 = 192;
pub const XCHAL_PS_OWB_BITS: u32 = 4;
pub const XCHAL_PS_OWB_NUM: u32 = 16;
pub const XCHAL_PS_OWB_SHIFT: u32 = 8;
pub const XCHAL_PS_OWB_MASK: u32 = 3840;
pub const XCHAL_PS_CALLINC_BITS: u32 = 2;
pub const XCHAL_PS_CALLINC_NUM: u32 = 4;
pub const XCHAL_PS_CALLINC_SHIFT: u32 = 16;
pub const XCHAL_PS_CALLINC_MASK: u32 = 196608;
pub const XCHAL_PS_WOE_BITS: u32 = 1;
pub const XCHAL_PS_WOE_NUM: u32 = 2;
pub const XCHAL_PS_WOE_SHIFT: u32 = 18;
pub const XCHAL_PS_WOE_MASK: u32 = 262144;
pub const XCHAL_EXCCAUSE_VALIDMASK: u32 = 63;
pub const XCHAL_EXCCAUSE_BITS: u32 = 6;
pub const XCHAL_EXCCAUSE_NUM: u32 = 64;
pub const XCHAL_EXCCAUSE_SHIFT: u32 = 0;
pub const XCHAL_EXCCAUSE_MASK: u32 = 63;
pub const XCHAL_DEBUGCAUSE_VALIDMASK: u32 = 63;
pub const XCHAL_DEBUGCAUSE_ICOUNT_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_ICOUNT_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_ICOUNT_SHIFT: u32 = 0;
pub const XCHAL_DEBUGCAUSE_ICOUNT_MASK: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_IBREAK_SHIFT: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_MASK: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_DBREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_SHIFT: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_MASK: u32 = 4;
pub const XCHAL_DEBUGCAUSE_BREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_BREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_BREAK_SHIFT: u32 = 3;
pub const XCHAL_DEBUGCAUSE_BREAK_MASK: u32 = 8;
pub const XCHAL_DEBUGCAUSE_BREAKN_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_BREAKN_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_BREAKN_SHIFT: u32 = 4;
pub const XCHAL_DEBUGCAUSE_BREAKN_MASK: u32 = 16;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_SHIFT: u32 = 5;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_MASK: u32 = 32;
pub const XCHAL_NUM_IROM: u32 = 1;
pub const XCHAL_NUM_IRAM: u32 = 2;
pub const XCHAL_NUM_DROM: u32 = 1;
pub const XCHAL_NUM_DRAM: u32 = 2;
pub const XCHAL_IROM0_VADDR: u32 = 1075838976;
pub const XCHAL_IROM0_PADDR: u32 = 1075838976;
pub const XCHAL_IROM0_SIZE: u32 = 1048576;
pub const XCHAL_IRAM0_VADDR: u32 = 1073741824;
pub const XCHAL_IRAM0_PADDR: u32 = 1073741824;
pub const XCHAL_IRAM0_SIZE: u32 = 1048576;
pub const XCHAL_IRAM1_VADDR: u32 = 1074790400;
pub const XCHAL_IRAM1_PADDR: u32 = 1074790400;
pub const XCHAL_IRAM1_SIZE: u32 = 1048576;
pub const XCHAL_DROM0_VADDR: u32 = 1072955392;
pub const XCHAL_DROM0_PADDR: u32 = 1072955392;
pub const XCHAL_DROM0_SIZE: u32 = 262144;
pub const XCHAL_DRAM0_VADDR: u32 = 1073479680;
pub const XCHAL_DRAM0_PADDR: u32 = 1073479680;
pub const XCHAL_DRAM0_SIZE: u32 = 262144;
pub const XCHAL_DRAM1_VADDR: u32 = 1073217536;
pub const XCHAL_DRAM1_PADDR: u32 = 1073217536;
pub const XCHAL_DRAM1_SIZE: u32 = 262144;
pub const XCHAL_CACHE_PREFCTL_DEFAULT: u32 = 68;
pub const XCHAL_CACHE_LINEWIDTH_MAX: u32 = 2;
pub const XCHAL_CACHE_LINESIZE_MAX: u32 = 4;
pub const XCHAL_ICACHE_SETSIZE: u32 = 1;
pub const XCHAL_DCACHE_SETSIZE: u32 = 1;
pub const XCHAL_CACHE_SETWIDTH_MAX: u32 = 0;
pub const XCHAL_CACHE_SETSIZE_MAX: u32 = 1;
pub const XCHAL_ICACHE_TAG_V_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_V: u32 = 1;
pub const XCHAL_ICACHE_TAG_F_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_F: u32 = 0;
pub const XCHAL_ICACHE_TAG_L_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_L: u32 = 0;
pub const XCHAL_DCACHE_TAG_V_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_V: u32 = 1;
pub const XCHAL_DCACHE_TAG_F_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_F: u32 = 0;
pub const XCHAL_DCACHE_TAG_D_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_D: u32 = 0;
pub const XCHAL_DCACHE_TAG_L_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_L: u32 = 0;
pub const XCHAL_ALIGN_MAX: u32 = 4;
pub const XCHAL_HW_RELEASE_MAJOR: u32 = 2300;
pub const XCHAL_HW_RELEASE_MINOR: u32 = 1;
pub const XCHAL_HW_RELEASE_NAME: &'static [u8; 8usize] = b"LX3.0.1\0";
pub const XCHAL_EXTRA_SA_SIZE: u32 = 0;
pub const XCHAL_EXTRA_SA_ALIGN: u32 = 1;
pub const XCHAL_CPEXTRA_SA_SIZE: u32 = 0;
pub const XCHAL_CPEXTRA_SA_ALIGN: u32 = 1;
pub const XCHAL_CP0_NAME: u32 = 0;
pub const XCHAL_CP0_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP1_NAME: u32 = 0;
pub const XCHAL_CP1_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP2_NAME: u32 = 0;
pub const XCHAL_CP2_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP3_NAME: u32 = 0;
pub const XCHAL_CP3_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP4_NAME: u32 = 0;
pub const XCHAL_CP4_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP5_NAME: u32 = 0;
pub const XCHAL_CP5_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP6_NAME: u32 = 0;
pub const XCHAL_CP6_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP7_NAME: u32 = 0;
pub const XCHAL_CP7_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP0_SA_SIZE: u32 = 0;
pub const XCHAL_CP0_SA_ALIGN: u32 = 1;
pub const XCHAL_CP1_SA_SIZE: u32 = 0;
pub const XCHAL_CP1_SA_ALIGN: u32 = 1;
pub const XCHAL_CP2_SA_SIZE: u32 = 0;
pub const XCHAL_CP2_SA_ALIGN: u32 = 1;
pub const XCHAL_CP3_SA_SIZE: u32 = 0;
pub const XCHAL_CP3_SA_ALIGN: u32 = 1;
pub const XCHAL_CP4_SA_SIZE: u32 = 0;
pub const XCHAL_CP4_SA_ALIGN: u32 = 1;
pub const XCHAL_CP5_SA_SIZE: u32 = 0;
pub const XCHAL_CP5_SA_ALIGN: u32 = 1;
pub const XCHAL_CP6_SA_SIZE: u32 = 0;
pub const XCHAL_CP6_SA_ALIGN: u32 = 1;
pub const XCHAL_CP7_SA_SIZE: u32 = 0;
pub const XCHAL_CP7_SA_ALIGN: u32 = 1;
pub const XCHAL_CPEXTRA_SA_SIZE_TOR2: u32 = 0;
pub const XCHAL_INST_ILLN: u32 = 61549;
pub const XCHAL_INST_ILLN_BYTE0: u32 = 109;
pub const XCHAL_INST_ILLN_BYTE1: u32 = 240;
pub const XTHAL_INST_ILL: u32 = 0;
pub const EXCCAUSE_EXCCAUSE_SHIFT: u32 = 0;
pub const EXCCAUSE_EXCCAUSE_MASK: u32 = 63;
pub const EXCCAUSE_ILLEGAL: u32 = 0;
pub const EXCCAUSE_SYSCALL: u32 = 1;
pub const EXCCAUSE_INSTR_ERROR: u32 = 2;
pub const EXCCAUSE_IFETCHERROR: u32 = 2;
pub const EXCCAUSE_LOAD_STORE_ERROR: u32 = 3;
pub const EXCCAUSE_LOADSTOREERROR: u32 = 3;
pub const EXCCAUSE_LEVEL1_INTERRUPT: u32 = 4;
pub const EXCCAUSE_LEVEL1INTERRUPT: u32 = 4;
pub const EXCCAUSE_ALLOCA: u32 = 5;
pub const EXCCAUSE_DIVIDE_BY_ZERO: u32 = 6;
pub const EXCCAUSE_SPECULATION: u32 = 7;
pub const EXCCAUSE_PRIVILEGED: u32 = 8;
pub const EXCCAUSE_UNALIGNED: u32 = 9;
pub const EXCCAUSE_INSTR_DATA_ERROR: u32 = 12;
pub const EXCCAUSE_LOAD_STORE_DATA_ERROR: u32 = 13;
pub const EXCCAUSE_INSTR_ADDR_ERROR: u32 = 14;
pub const EXCCAUSE_LOAD_STORE_ADDR_ERROR: u32 = 15;
pub const EXCCAUSE_ITLB_MISS: u32 = 16;
pub const EXCCAUSE_ITLB_MULTIHIT: u32 = 17;
pub const EXCCAUSE_INSTR_RING: u32 = 18;
pub const EXCCAUSE_INSTR_PROHIBITED: u32 = 20;
pub const EXCCAUSE_DTLB_MISS: u32 = 24;
pub const EXCCAUSE_DTLB_MULTIHIT: u32 = 25;
pub const EXCCAUSE_LOAD_STORE_RING: u32 = 26;
pub const EXCCAUSE_LOAD_PROHIBITED: u32 = 28;
pub const EXCCAUSE_STORE_PROHIBITED: u32 = 29;
pub const EXCCAUSE_CP0_DISABLED: u32 = 32;
pub const EXCCAUSE_CP1_DISABLED: u32 = 33;
pub const EXCCAUSE_CP2_DISABLED: u32 = 34;
pub const EXCCAUSE_CP3_DISABLED: u32 = 35;
pub const EXCCAUSE_CP4_DISABLED: u32 = 36;
pub const EXCCAUSE_CP5_DISABLED: u32 = 37;
pub const EXCCAUSE_CP6_DISABLED: u32 = 38;
pub const EXCCAUSE_CP7_DISABLED: u32 = 39;
pub const PS_WOE_SHIFT: u32 = 18;
pub const PS_WOE_MASK: u32 = 262144;
pub const PS_WOE: u32 = 262144;
pub const PS_CALLINC_SHIFT: u32 = 16;
pub const PS_CALLINC_MASK: u32 = 196608;
pub const PS_OWB_SHIFT: u32 = 8;
pub const PS_OWB_MASK: u32 = 3840;
pub const PS_RING_SHIFT: u32 = 6;
pub const PS_RING_MASK: u32 = 192;
pub const PS_UM_SHIFT: u32 = 5;
pub const PS_UM_MASK: u32 = 32;
pub const PS_UM: u32 = 32;
pub const PS_EXCM_SHIFT: u32 = 4;
pub const PS_EXCM_MASK: u32 = 16;
pub const PS_EXCM: u32 = 16;
pub const PS_INTLEVEL_SHIFT: u32 = 0;
pub const PS_INTLEVEL_MASK: u32 = 15;
pub const PS_PROGSTACK_SHIFT: u32 = 5;
pub const PS_PROGSTACK_MASK: u32 = 32;
pub const PS_PROG_SHIFT: u32 = 5;
pub const PS_PROG_MASK: u32 = 32;
pub const PS_PROG: u32 = 32;
pub const DBREAKC_MASK_SHIFT: u32 = 0;
pub const DBREAKC_MASK_MASK: u32 = 63;
pub const DBREAKC_LOADBREAK_SHIFT: u32 = 30;
pub const DBREAKC_LOADBREAK_MASK: u32 = 1073741824;
pub const DBREAKC_STOREBREAK_SHIFT: u32 = 31;
pub const DBREAKC_STOREBREAK_MASK: u32 = 2147483648;
pub const DEBUGCAUSE_DEBUGINT_SHIFT: u32 = 5;
pub const DEBUGCAUSE_DEBUGINT_MASK: u32 = 32;
pub const DEBUGCAUSE_BREAKN_SHIFT: u32 = 4;
pub const DEBUGCAUSE_BREAKN_MASK: u32 = 16;
pub const DEBUGCAUSE_BREAK_SHIFT: u32 = 3;
pub const DEBUGCAUSE_BREAK_MASK: u32 = 8;
pub const DEBUGCAUSE_DBREAK_SHIFT: u32 = 2;
pub const DEBUGCAUSE_DBREAK_MASK: u32 = 4;
pub const DEBUGCAUSE_IBREAK_SHIFT: u32 = 1;
pub const DEBUGCAUSE_IBREAK_MASK: u32 = 2;
pub const DEBUGCAUSE_ICOUNT_SHIFT: u32 = 0;
pub const DEBUGCAUSE_ICOUNT_MASK: u32 = 1;
pub const MESR_MEME: u32 = 1;
pub const MESR_MEME_SHIFT: u32 = 0;
pub const MESR_DME: u32 = 2;
pub const MESR_DME_SHIFT: u32 = 1;
pub const MESR_RCE: u32 = 16;
pub const MESR_RCE_SHIFT: u32 = 4;
pub const MESR_ERRENAB: u32 = 256;
pub const MESR_ERRENAB_SHIFT: u32 = 8;
pub const MESR_ERRTEST: u32 = 512;
pub const MESR_ERRTEST_SHIFT: u32 = 9;
pub const MESR_DATEXC: u32 = 1024;
pub const MESR_DATEXC_SHIFT: u32 = 10;
pub const MESR_INSEXC: u32 = 2048;
pub const MESR_INSEXC_SHIFT: u32 = 11;
pub const MESR_WAYNUM_SHIFT: u32 = 16;
pub const MESR_ACCTYPE_SHIFT: u32 = 20;
pub const MESR_MEMTYPE_SHIFT: u32 = 24;
pub const MESR_ERRTYPE_SHIFT: u32 = 30;
pub const SAR: u32 = 3;
pub const LITBASE: u32 = 5;
pub const IBREAKENABLE: u32 = 96;
pub const DDR: u32 = 104;
pub const IBREAKA_0: u32 = 128;
pub const DBREAKA_0: u32 = 144;
pub const DBREAKC_0: u32 = 160;
pub const EPC_1: u32 = 177;
pub const EPC_2: u32 = 178;
pub const EPC_3: u32 = 179;
pub const DEPC: u32 = 192;
pub const EPS_2: u32 = 194;
pub const EPS_3: u32 = 195;
pub const EXCSAVE_1: u32 = 209;
pub const EXCSAVE_2: u32 = 210;
pub const EXCSAVE_3: u32 = 211;
pub const INTERRUPT: u32 = 226;
pub const INTENABLE: u32 = 228;
pub const PS: u32 = 230;
pub const VECBASE: u32 = 231;
pub const EXCCAUSE: u32 = 232;
pub const DEBUGCAUSE: u32 = 233;
pub const CCOUNT: u32 = 234;
pub const PRID: u32 = 235;
pub const ICOUNT: u32 = 236;
pub const ICOUNTLEVEL: u32 = 237;
pub const EXCVADDR: u32 = 238;
pub const CCOMPARE_0: u32 = 240;
pub const IBREAKA: u32 = 128;
pub const DBREAKA: u32 = 144;
pub const DBREAKC: u32 = 160;
pub const EPC: u32 = 176;
pub const EPS: u32 = 192;
pub const EXCSAVE: u32 = 208;
pub const CCOMPARE: u32 = 240;
pub const INTREAD: u32 = 226;
pub const INTSET: u32 = 226;
pub const INTCLEAR: u32 = 227;
pub const XSHAL_USE_ABSOLUTE_LITERALS: u32 = 0;
pub const XTHAL_ABI_WINDOWED: u32 = 0;
pub const XTHAL_ABI_CALL0: u32 = 1;
pub const XTHAL_CLIB_NEWLIB: u32 = 0;
pub const XTHAL_CLIB_UCLIBC: u32 = 1;
pub const XSHAL_USE_FLOATING_POINT: u32 = 1;
pub const XSHAL_IOBLOCK_CACHED_VADDR: u32 = 1879048192;
pub const XSHAL_IOBLOCK_CACHED_PADDR: u32 = 1879048192;
pub const XSHAL_IOBLOCK_CACHED_SIZE: u32 = 234881024;
pub const XSHAL_IOBLOCK_BYPASS_VADDR: u32 = 2415919104;
pub const XSHAL_IOBLOCK_BYPASS_PADDR: u32 = 2415919104;
pub const XSHAL_IOBLOCK_BYPASS_SIZE: u32 = 234881024;
pub const XSHAL_ROM_VADDR: u32 = 1342177280;
pub const XSHAL_ROM_PADDR: u32 = 1342177280;
pub const XSHAL_ROM_SIZE: u32 = 16777216;
pub const XSHAL_ROM_AVAIL_VADDR: u32 = 1342178048;
pub const XSHAL_ROM_AVAIL_VSIZE: u32 = 16776448;
pub const XSHAL_RAM_VADDR: u32 = 1610612736;
pub const XSHAL_RAM_PADDR: u32 = 1610612736;
pub const XSHAL_RAM_VSIZE: u32 = 67108864;
pub const XSHAL_RAM_PSIZE: u32 = 67108864;
pub const XSHAL_RAM_SIZE: u32 = 67108864;
pub const XSHAL_RAM_AVAIL_VADDR: u32 = 1610612736;
pub const XSHAL_RAM_AVAIL_VSIZE: u32 = 67108864;
pub const XSHAL_RAM_BYPASS_VADDR: u32 = 2684354560;
pub const XSHAL_RAM_BYPASS_PADDR: u32 = 2684354560;
pub const XSHAL_RAM_BYPASS_PSIZE: u32 = 67108864;
pub const XSHAL_SIMIO_CACHED_VADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_BYPASS_VADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_PADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_SIZE: u32 = 536870912;
pub const XSHAL_ALLVALID_CACHEATTR_WRITEBACK: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_WRITEALLOC: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_WRITETHRU: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_BYPASS: u32 = 572662306;
pub const XSHAL_ALLVALID_CACHEATTR_DEFAULT: u32 = 572657938;
pub const XSHAL_STRICT_CACHEATTR_WRITEBACK: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_WRITEALLOC: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_WRITETHRU: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_BYPASS: u32 = 4294910511;
pub const XSHAL_STRICT_CACHEATTR_DEFAULT: u32 = 4294906143;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITEBACK: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITEALLOC: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITETHRU: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_BYPASS: u32 = 572662319;
pub const XSHAL_TRAPNULL_CACHEATTR_DEFAULT: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITEBACK: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITEALLOC: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITETHRU: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_BYPASS: u32 = 572662319;
pub const XSHAL_ISS_CACHEATTR_DEFAULT: u32 = 572657951;
pub const XSHAL_ISS_PIPE_REGIONS: u32 = 0;
pub const XSHAL_ISS_SDRAM_REGIONS: u32 = 0;
pub const XSHAL_XT2000_CACHEATTR_WRITEBACK: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_WRITEALLOC: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_WRITETHRU: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_BYPASS: u32 = 4280427055;
pub const XSHAL_XT2000_CACHEATTR_DEFAULT: u32 = 4280422687;
pub const XSHAL_XT2000_PIPE_REGIONS: u32 = 0;
pub const XSHAL_XT2000_SDRAM_REGIONS: u32 = 1088;
pub const XSHAL_VECTORS_PACKED: u32 = 0;
pub const XSHAL_STATIC_VECTOR_SELECT: u32 = 0;
pub const XSHAL_RESET_VECTOR_VADDR: u32 = 1342177280;
pub const XSHAL_RESET_VECTOR_PADDR: u32 = 1342177280;
pub const XSHAL_RESET_VECTOR_SIZE: u32 = 768;
pub const XSHAL_RESET_VECTOR_ISROM: u32 = 1;
pub const XSHAL_USER_VECTOR_SIZE: u32 = 28;
pub const XSHAL_USER_VECTOR_ISROM: u32 = 0;
pub const XSHAL_PROGRAMEXC_VECTOR_SIZE: u32 = 28;
pub const XSHAL_USEREXC_VECTOR_SIZE: u32 = 28;
pub const XSHAL_KERNEL_VECTOR_SIZE: u32 = 28;
pub const XSHAL_KERNEL_VECTOR_ISROM: u32 = 0;
pub const XSHAL_STACKEDEXC_VECTOR_SIZE: u32 = 28;
pub const XSHAL_KERNELEXC_VECTOR_SIZE: u32 = 28;
pub const XSHAL_DOUBLEEXC_VECTOR_SIZE: u32 = 16;
pub const XSHAL_DOUBLEEXC_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL2_VECTOR_SIZE: u32 = 12;
pub const XSHAL_INTLEVEL2_VECTOR_ISROM: u32 = 0;
pub const XSHAL_DEBUG_VECTOR_SIZE: u32 = 12;
pub const XSHAL_DEBUG_VECTOR_ISROM: u32 = 0;
pub const XSHAL_NMI_VECTOR_SIZE: u32 = 12;
pub const XSHAL_NMI_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL3_VECTOR_SIZE: u32 = 12;
pub const SYS_nop: u32 = 0;
pub const SYS_exit: u32 = 1;
pub const SYS_fork: u32 = 2;
pub const SYS_read: u32 = 3;
pub const SYS_write: u32 = 4;
pub const SYS_open: u32 = 5;
pub const SYS_close: u32 = 6;
pub const SYS_rename: u32 = 7;
pub const SYS_creat: u32 = 8;
pub const SYS_link: u32 = 9;
pub const SYS_unlink: u32 = 10;
pub const SYS_execv: u32 = 11;
pub const SYS_execve: u32 = 12;
pub const SYS_pipe: u32 = 13;
pub const SYS_stat: u32 = 14;
pub const SYS_chmod: u32 = 15;
pub const SYS_chown: u32 = 16;
pub const SYS_utime: u32 = 17;
pub const SYS_wait: u32 = 18;
pub const SYS_lseek: u32 = 19;
pub const SYS_getpid: u32 = 20;
pub const SYS_isatty: u32 = 21;
pub const SYS_fstat: u32 = 22;
pub const SYS_time: u32 = 23;
pub const SYS_gettimeofday: u32 = 24;
pub const SYS_times: u32 = 25;
pub const SYS_socket: u32 = 26;
pub const SYS_sendto: u32 = 27;
pub const SYS_recvfrom: u32 = 28;
pub const SYS_select_one: u32 = 29;
pub const SYS_bind: u32 = 30;
pub const SYS_ioctl: u32 = 31;
pub const SYS_iss_argc: u32 = 1000;
pub const SYS_iss_argv_size: u32 = 1001;
pub const SYS_iss_set_argv: u32 = 1002;
pub const SYS_memset: u32 = 1004;
pub const SYS_ferret: u32 = 1010;
pub const SYS_malloc: u32 = 1011;
pub const SYS_free: u32 = 1012;
pub const SYS_more_heap: u32 = 1013;
pub const SYS_no_heap: u32 = 1014;
pub const SYS_enter_ferret: u32 = 1015;
pub const SYS_leave_ferret: u32 = 1016;
pub const SYS_profile_enable: u32 = 1020;
pub const SYS_profile_disable: u32 = 1021;
pub const SYS_trace_level: u32 = 1022;
pub const SYS_client_command: u32 = 1023;
pub const SYS_sim_mode_switch: u32 = 1030;
pub const SYS_event_fire: u32 = 1040;
pub const SYS_event_stall: u32 = 1041;
pub const SYS_callback_first: u32 = 100;
pub const SYS_callback_last: u32 = 999;
pub const SYS_user_simcall: u32 = 100;
pub const SYS_xmpa_errinfo: u32 = 200;
pub const SYS_xmpa_proc_status: u32 = 201;
pub const SYS_xmpa_proc_start: u32 = 202;
pub const SYS_xmpa_proc_stop: u32 = 203;
pub const SYS_xmpa_proc_mem_read: u32 = 204;
pub const SYS_xmpa_proc_mem_write: u32 = 205;
pub const SYS_xmpa_proc_mem_fill: u32 = 206;
pub const SYS_xmpa_proc_reg_read: u32 = 207;
pub const SYS_xmpa_proc_reg_write: u32 = 208;
pub const SYS_gdb_break: i32 = -1;
pub const SYS_xmon_out: i32 = -2;
pub const SYS_xmon_in: i32 = -3;
pub const SYS_xmon_flush: i32 = -4;
pub const SYS_gdb_abort: i32 = -5;
pub const SYS_gdb_illegal_inst: i32 = -6;
pub const SYS_xmon_init: i32 = -7;
pub const SYS_gdb_enter_sktloop: i32 = -8;
pub const SYS_unhandled_kernel_exc: i32 = -9;
pub const SYS_unhandled_user_exc: i32 = -10;
pub const SYS_unhandled_double_exc: i32 = -11;
pub const SYS_unhandled_highpri_interrupt: i32 = -12;
pub const SYS_setup_ppp_pipes: i32 = -83;
pub const SYS_log_msg: i32 = -84;
pub const XTISS_SELECT_ONE_READ: u32 = 1;
pub const XTISS_SELECT_ONE_WRITE: u32 = 2;
pub const XTISS_SELECT_ONE_EXCEPT: u32 = 3;
pub const SYS_client: u32 = 3235826430;
pub const XT_INTEXC_HOOK_NUM: u32 = 4;
pub const CALL0_ABI: u32 = 0;
pub const ALIGNPAD: u32 = 3;
pub const KERNELSTACKSIZE: u32 = 1024;
pub const XT_STK_EXIT: u32 = 0;
pub const XT_STK_PC: u32 = 4;
pub const XT_STK_PS: u32 = 8;
pub const XT_STK_A0: u32 = 12;
pub const XT_STK_A1: u32 = 16;
pub const XT_STK_A2: u32 = 20;
pub const XT_STK_A3: u32 = 24;
pub const XT_STK_A4: u32 = 28;
pub const XT_STK_A5: u32 = 32;
pub const XT_STK_A6: u32 = 36;
pub const XT_STK_A7: u32 = 40;
pub const XT_STK_A8: u32 = 44;
pub const XT_STK_A9: u32 = 48;
pub const XT_STK_A10: u32 = 52;
pub const XT_STK_A11: u32 = 56;
pub const XT_STK_A12: u32 = 60;
pub const XT_STK_A13: u32 = 64;
pub const XT_STK_A14: u32 = 68;
pub const XT_STK_A15: u32 = 72;
pub const XT_STK_SAR: u32 = 76;
pub const XT_STK_EXCCAUSE: u32 = 80;
pub const XT_STK_EXCVADDR: u32 = 84;
pub const XT_STK_NEXT1: u32 = 80;
pub const XT_STK_NEXT2: u32 = 80;
pub const XT_STK_N_TMP: u32 = 3;
pub const XT_STK_TMP: u32 = 80;
pub const XT_STK_NEXT3: u32 = 92;
pub const XT_SOL_EXIT: u32 = 0;
pub const XT_SOL_PC: u32 = 4;
pub const XT_SOL_PS: u32 = 8;
pub const XT_SOL_NEXT: u32 = 12;
pub const XT_CP_SIZE: u32 = 0;
pub const XT_TIMER_INDEX: u32 = 0;
pub const XT_CCOMPARE: u32 = 240;
pub const XT_TICK_PER_SEC: u32 = 100;
pub const portSTACK_GROWTH: i32 = -1;
pub const portBYTE_ALIGNMENT: u32 = 4;
pub const portBYTE_ALIGNMENT_MASK: u32 = 3;
pub const portNUM_CONFIGURABLE_REGIONS: u32 = 1;
pub const portUSING_MPU_WRAPPERS: u32 = 0;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _ASSERT_H: u32 = 1;
pub const ESP_OK: u32 = 0;
pub const ESP_FAIL: i32 = -1;
pub const ESP_ERR_NO_MEM: u32 = 257;
pub const ESP_ERR_INVALID_ARG: u32 = 258;
pub const ESP_ERR_INVALID_STATE: u32 = 259;
pub const ESP_ERR_INVALID_SIZE: u32 = 260;
pub const ESP_ERR_NOT_FOUND: u32 = 261;
pub const ESP_ERR_NOT_SUPPORTED: u32 = 262;
pub const ESP_ERR_TIMEOUT: u32 = 263;
pub const ESP_ERR_INVALID_RESPONSE: u32 = 264;
pub const ESP_ERR_INVALID_CRC: u32 = 265;
pub const ESP_ERR_INVALID_VERSION: u32 = 266;
pub const ESP_ERR_INVALID_MAC: u32 = 267;
pub const ESP_ERR_WIFI_BASE: u32 = 12288;
pub const ESP_ERR_MESH_BASE: u32 = 16384;
pub const HEAP_ALIGN_SIZE: u32 = 4;
pub const HEAP_REGIONS_MAX: u32 = 2;
pub const MEM_BLK_MIN: u32 = 1;
pub const MALLOC_CAP_EXEC: u32 = 1;
pub const MALLOC_CAP_32BIT: u32 = 2;
pub const MALLOC_CAP_8BIT: u32 = 4;
pub const MALLOC_CAP_DMA: u32 = 8;
pub const MALLOC_CAP_INTERNAL: u32 = 2048;
pub const MALLOC_CAP_SPIRAM: u32 = 1024;
pub const pvMALLOC_DRAM: u32 = 14;
pub const pvMALLOC_IRAM: u32 = 2;
pub const configUSE_NEWLIB_REENTRANT: u32 = 0;
pub const INCLUDE_xTaskAbortDelay: u32 = 0;
pub const INCLUDE_xQueueGetMutexHolder: u32 = 0;
pub const INCLUDE_xTaskGetHandle: u32 = 0;
pub const INCLUDE_eTaskGetState: u32 = 0;
pub const INCLUDE_xTaskResumeFromISR: u32 = 1;
pub const INCLUDE_xTaskGetSchedulerState: u32 = 0;
pub const configUSE_DAEMON_TASK_STARTUP_HOOK: u32 = 0;
pub const configUSE_APPLICATION_TASK_TAG: u32 = 0;
pub const configUSE_ALTERNATIVE_API: u32 = 0;
pub const portCRITICAL_NESTING_IN_TCB: u32 = 0;
pub const configASSERT_DEFINED: u32 = 0;
pub const configQUEUE_REGISTRY_SIZE: u32 = 0;
pub const configCHECK_FOR_STACK_OVERFLOW: u32 = 0;
pub const configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H: u32 = 0;
pub const configGENERATE_RUN_TIME_STATS: u32 = 0;
pub const configUSE_MALLOC_FAILED_HOOK: u32 = 0;
pub const configEXPECTED_IDLE_TIME_BEFORE_SLEEP: u32 = 2;
pub const configUSE_QUEUE_SETS: u32 = 0;
pub const configUSE_TIME_SLICING: u32 = 1;
pub const configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS: u32 = 0;
pub const configUSE_STATS_FORMATTING_FUNCTIONS: u32 = 0;
pub const configUSE_TRACE_FACILITY: u32 = 0;
pub const configUSE_PORT_OPTIMISED_TASK_SELECTION: u32 = 0;
pub const configAPPLICATION_ALLOCATED_HEAP: u32 = 0;
pub const configUSE_TASK_NOTIFICATIONS: u32 = 1;
pub const portTICK_TYPE_IS_ATOMIC: u32 = 0;
pub const configSUPPORT_STATIC_ALLOCATION: u32 = 0;
pub const configSUPPORT_DYNAMIC_ALLOCATION: u32 = 1;
pub const configINITIAL_TICK_COUNT: u32 = 0;
pub const configENABLE_BACKWARD_COMPATIBILITY: u32 = 1;
pub const configUSE_TASK_FPU_SUPPORT: u32 = 1;
pub const tskKERNEL_VERSION_NUMBER: &'static [u8; 8usize] = b"V10.0.1\0";
pub const tskKERNEL_VERSION_MAJOR: u32 = 10;
pub const tskKERNEL_VERSION_MINOR: u32 = 0;
pub const tskKERNEL_VERSION_BUILD: u32 = 1;
pub const PERIPHS_IO_MUX: u32 = 1610614784;
pub const PERIPHS_IO_MUX_FUNC: u32 = 19;
pub const PERIPHS_IO_MUX_FUNC_S: u32 = 4;
pub const PERIPHS_IO_MUX_PULLUP: u32 = 128;
pub const PERIPHS_IO_MUX_PULLDWN: u32 = 64;
pub const PERIPHS_IO_MUX_SLEEP_PULLUP: u32 = 8;
pub const PERIPHS_IO_MUX_SLEEP_PULLDWN: u32 = 4;
pub const PERIPHS_IO_MUX_SLEEP_OE: u32 = 2;
pub const PERIPHS_IO_MUX_OE: u32 = 1;
pub const PERIPHS_IO_MUX_CONF_U: u32 = 1610614784;
pub const SPI0_CLK_EQU_SYS_CLK: u32 = 256;
pub const SPI1_CLK_EQU_SYS_CLK: u32 = 512;
pub const PERIPHS_IO_MUX_MTDI_U: u32 = 1610614788;
pub const FUNC_MTDI: u32 = 0;
pub const FUNC_I2SI_DATA: u32 = 1;
pub const FUNC_HSPIQ_MISO: u32 = 2;
pub const FUNC_GPIO12: u32 = 3;
pub const FUNC_UART0_DTR: u32 = 4;
pub const PERIPHS_IO_MUX_MTCK_U: u32 = 1610614792;
pub const FUNC_MTCK: u32 = 0;
pub const FUNC_I2SI_BCK: u32 = 1;
pub const FUNC_HSPID_MOSI: u32 = 2;
pub const FUNC_GPIO13: u32 = 3;
pub const FUNC_UART0_CTS: u32 = 4;
pub const PERIPHS_IO_MUX_MTMS_U: u32 = 1610614796;
pub const FUNC_MTMS: u32 = 0;
pub const FUNC_I2SI_WS: u32 = 1;
pub const FUNC_HSPI_CLK: u32 = 2;
pub const FUNC_GPIO14: u32 = 3;
pub const FUNC_UART0_DSR: u32 = 4;
pub const PERIPHS_IO_MUX_MTDO_U: u32 = 1610614800;
pub const FUNC_MTDO: u32 = 0;
pub const FUNC_I2SO_BCK: u32 = 1;
pub const FUNC_HSPI_CS0: u32 = 2;
pub const FUNC_GPIO15: u32 = 3;
pub const FUNC_U0RTS: u32 = 4;
pub const FUNC_UART0_RTS: u32 = 4;
pub const PERIPHS_IO_MUX_U0RXD_U: u32 = 1610614804;
pub const FUNC_U0RXD: u32 = 0;
pub const FUNC_I2SO_DATA: u32 = 1;
pub const FUNC_GPIO3: u32 = 3;
pub const FUNC_CLK_XTAL_BK: u32 = 4;
pub const PERIPHS_IO_MUX_U0TXD_U: u32 = 1610614808;
pub const FUNC_U0TXD: u32 = 0;
pub const FUNC_SPICS1: u32 = 1;
pub const FUNC_GPIO1: u32 = 3;
pub const FUNC_CLK_RTC_BK: u32 = 4;
pub const PERIPHS_IO_MUX_SD_CLK_U: u32 = 1610614812;
pub const FUNC_SDCLK: u32 = 0;
pub const FUNC_SPICLK: u32 = 1;
pub const FUNC_GPIO6: u32 = 3;
pub const UART1_CTS: u32 = 4;
pub const PERIPHS_IO_MUX_SD_DATA0_U: u32 = 1610614816;
pub const FUNC_SDDATA0: u32 = 0;
pub const FUNC_SPIQ_MISO: u32 = 1;
pub const FUNC_GPIO7: u32 = 3;
pub const FUNC_U1TXD: u32 = 4;
pub const FUNC_UART1_TXD: u32 = 4;
pub const PERIPHS_IO_MUX_SD_DATA1_U: u32 = 1610614820;
pub const FUNC_SDDATA1: u32 = 0;
pub const FUNC_SPID_MOSI: u32 = 1;
pub const FUNC_GPIO8: u32 = 3;
pub const FUNC_U1RXD: u32 = 4;
pub const FUNC_UART1_RXD: u32 = 4;
pub const PERIPHS_IO_MUX_SD_DATA2_U: u32 = 1610614824;
pub const FUNC_SDDATA2: u32 = 0;
pub const FUNC_SPIHD: u32 = 1;
pub const FUNC_GPIO9: u32 = 3;
pub const UFNC_HSPIHD: u32 = 4;
pub const PERIPHS_IO_MUX_SD_DATA3_U: u32 = 1610614828;
pub const FUNC_SDDATA3: u32 = 0;
pub const FUNC_SPIWP: u32 = 1;
pub const FUNC_GPIO10: u32 = 3;
pub const FUNC_HSPIWP: u32 = 4;
pub const PERIPHS_IO_MUX_SD_CMD_U: u32 = 1610614832;
pub const FUNC_SDCMD: u32 = 0;
pub const FUNC_SPICS0: u32 = 1;
pub const FUNC_GPIO11: u32 = 3;
pub const U1RTS: u32 = 4;
pub const UART1_RTS: u32 = 4;
pub const PERIPHS_IO_MUX_GPIO0_U: u32 = 1610614836;
pub const FUNC_GPIO0: u32 = 0;
pub const FUNC_SPICS2: u32 = 1;
pub const FUNC_CLK_OUT: u32 = 4;
pub const PERIPHS_IO_MUX_GPIO2_U: u32 = 1610614840;
pub const FUNC_GPIO2: u32 = 0;
pub const FUNC_I2SO_WS: u32 = 1;
pub const FUNC_U1TXD_BK: u32 = 2;
pub const FUNC_UART1_TXD_BK: u32 = 2;
pub const FUNC_U0TXD_BK: u32 = 4;
pub const FUNC_UART0_TXD_BK: u32 = 4;
pub const PERIPHS_IO_MUX_GPIO4_U: u32 = 1610614844;
pub const FUNC_GPIO4: u32 = 0;
pub const FUNC_CLK_XTAL: u32 = 1;
pub const PERIPHS_IO_MUX_GPIO5_U: u32 = 1610614848;
pub const FUNC_GPIO5: u32 = 0;
pub const FUNC_CLK_RTC: u32 = 1;
pub const PERIPHS_GPIO_BASEADDR: u32 = 1610613504;
pub const GPIO_OUT_ADDRESS: u32 = 0;
pub const GPIO_BT_SEL: u32 = 65535;
pub const GPIO_BT_SEL_S: u32 = 16;
pub const GPIO_OUT_DATA: u32 = 65535;
pub const GPIO_OUT_DATA_S: u32 = 0;
pub const GPIO_OUT_W1TS_ADDRESS: u32 = 4;
pub const GPIO_OUT_DATA_W1TS: u32 = 65535;
pub const GPIO_OUT_DATA_W1TS_S: u32 = 0;
pub const GPIO_OUT_W1TC_ADDRESS: u32 = 8;
pub const GPIO_OUT_DATA_W1TC: u32 = 65535;
pub const GPIO_OUT_DATA_W1TC_S: u32 = 0;
pub const GPIO_OUT_DATA_MASK: u32 = 65535;
pub const GPIO_ENABLE_ADDRESS: u32 = 12;
pub const GPIO_SDIO_SEL: u32 = 63;
pub const GPIO_SDIO_SEL_S: u32 = 16;
pub const GPIO_ENABLE_DATA: u32 = 65535;
pub const GPIO_ENABLE_DATA_S: u32 = 0;
pub const GPIO_ENABLE_W1TS_ADDRESS: u32 = 16;
pub const GPIO_ENABLE_DATA_W1TS: u32 = 65535;
pub const GPIO_ENABLE_DATA_W1TS_s: u32 = 0;
pub const GPIO_ENABLE_W1TC_ADDRESS: u32 = 20;
pub const GPIO_ENABLE_DATA_W1TC: u32 = 65535;
pub const GPIO_ENABLE_DATA_W1TC_S: u32 = 0;
pub const GPIO_ENABLE_DATA_DATA_MASK: u32 = 65535;
pub const GPIO_IN_ADDRESS: u32 = 24;
pub const GPIO_STRAPPING: u32 = 65535;
pub const GPIO_STRAPPING_S: u32 = 16;
pub const GPIO_IN_DATA: u32 = 65535;
pub const GPIO_IN_DATA_S: u32 = 0;
pub const GPIO_STATUS_ADDRESS: u32 = 28;
pub const GPIO_STATUS_INTERRUPT: u32 = 65535;
pub const GPIO_STATUS_INTERRUPT_S: u32 = 0;
pub const GPIO_STATUS_W1TS_ADDRESS: u32 = 32;
pub const GPIO_STATUS_INTERRUPT_W1TS: u32 = 65535;
pub const GPIO_STATUS_INTERRUPT_W1TS_S: u32 = 0;
pub const GPIO_STATUS_W1TC_ADDRESS: u32 = 36;
pub const GPIO_STATUS_INTERRUPT_W1TC: u32 = 65535;
pub const GPIO_STATUS_INTERRUPT_W1TC_S: u32 = 0;
pub const GPIO_STATUS_INTERRUPT_DATA_MASK: u32 = 65535;
pub const GPIO_ID_PIN0: u32 = 0;
pub const GPIO_ID_NONE: u32 = 4294967295;
pub const GPIO_PIN_CONFIG_MSB: u32 = 12;
pub const GPIO_PIN_CONFIG_LSB: u32 = 11;
pub const GPIO_PIN_CONFIG_MASK: u32 = 6144;
pub const GPIO_WAKEUP_ENABLE: u32 = 1;
pub const GPIO_WAKEUP_DISABLE: i32 = -2;
pub const GPIO_PIN_WAKEUP_ENABLE_MSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_LSB: u32 = 10;
pub const GPIO_PIN_WAKEUP_ENABLE_MASK: u32 = 1024;
pub const GPIO_PIN_INT_TYPE_MSB: u32 = 9;
pub const GPIO_PIN_INT_TYPE_LSB: u32 = 7;
pub const GPIO_PIN_INT_TYPE_MASK: u32 = 896;
pub const GPIO_PAD_DRIVER_ENABLE: u32 = 1;
pub const GPIO_PAD_DRIVER_DISABLE: i32 = -2;
pub const GPIO_PIN_DRIVER_MSB: u32 = 2;
pub const GPIO_PIN_DRIVER_LSB: u32 = 2;
pub const GPIO_PIN_DRIVER_MASK: u32 = 4;
pub const GPIO_PIN_SOURCE_MSB: u32 = 0;
pub const GPIO_PIN_SOURCE_LSB: u32 = 0;
pub const GPIO_PIN_SOURCE_MASK: u32 = 1;
pub const GPIO_PIN0_ADDRESS: u32 = 40;
pub const GPIO_PIN0_CONFIG: u32 = 3;
pub const GPIO_PIN0_CONFIG_S: u32 = 11;
pub const GPIO_PIN0_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN0_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN0_INT_TYPE: u32 = 7;
pub const GPIO_PIN0_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN0_DRIVER: u32 = 4;
pub const GPIO_PIN0_DRIVER_S: u32 = 2;
pub const GPIO_PIN0_SOURCE: u32 = 1;
pub const GPIO_PIN0_SOURCE_S: u32 = 0;
pub const GPIO_PIN1_ADDRESS: u32 = 44;
pub const GPIO_PIN1_CONFIG: u32 = 3;
pub const GPIO_PIN1_CONFIG_S: u32 = 11;
pub const GPIO_PIN1_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN1_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN1_INT_TYPE: u32 = 7;
pub const GPIO_PIN1_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN1_DRIVER: u32 = 4;
pub const GPIO_PIN1_DRIVER_S: u32 = 2;
pub const GPIO_PIN1_SOURCE: u32 = 1;
pub const GPIO_PIN1_SOURCE_S: u32 = 0;
pub const GPIO_PIN2_ADDRESS: u32 = 48;
pub const GPIO_PIN2_CONFIG: u32 = 3;
pub const GPIO_PIN2_CONFIG_S: u32 = 11;
pub const GPIO_PIN2_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN2_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN2_INT_TYPE: u32 = 7;
pub const GPIO_PIN2_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN2_DRIVER: u32 = 4;
pub const GPIO_PIN2_DRIVER_S: u32 = 2;
pub const GPIO_PIN2_SOURCE: u32 = 1;
pub const GPIO_PIN2_SOURCE_S: u32 = 0;
pub const GPIO_PIN3_ADDRESS: u32 = 52;
pub const GPIO_PIN3_CONFIG: u32 = 3;
pub const GPIO_PIN3_CONFIG_S: u32 = 11;
pub const GPIO_PIN3_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN3_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN3_INT_TYPE: u32 = 7;
pub const GPIO_PIN3_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN3_DRIVER: u32 = 4;
pub const GPIO_PIN3_DRIVER_S: u32 = 2;
pub const GPIO_PIN3_SOURCE: u32 = 1;
pub const GPIO_PIN3_SOURCE_S: u32 = 0;
pub const GPIO_PIN4_ADDRESS: u32 = 56;
pub const GPIO_PIN4_CONFIG: u32 = 3;
pub const GPIO_PIN4_CONFIG_S: u32 = 11;
pub const GPIO_PIN4_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN4_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN4_INT_TYPE: u32 = 7;
pub const GPIO_PIN4_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN4_DRIVER: u32 = 4;
pub const GPIO_PIN4_DRIVER_S: u32 = 2;
pub const GPIO_PIN4_SOURCE: u32 = 1;
pub const GPIO_PIN4_SOURCE_S: u32 = 0;
pub const GPIO_PIN5_ADDRESS: u32 = 60;
pub const GPIO_PIN5_CONFIG: u32 = 3;
pub const GPIO_PIN5_CONFIG_S: u32 = 11;
pub const GPIO_PIN5_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN5_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN5_INT_TYPE: u32 = 7;
pub const GPIO_PIN5_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN5_DRIVER: u32 = 4;
pub const GPIO_PIN5_DRIVER_S: u32 = 2;
pub const GPIO_PIN5_SOURCE: u32 = 1;
pub const GPIO_PIN5_SOURCE_S: u32 = 0;
pub const GPIO_PIN6_ADDRESS: u32 = 64;
pub const GPIO_PIN6_CONFIG: u32 = 3;
pub const GPIO_PIN6_CONFIG_S: u32 = 11;
pub const GPIO_PIN6_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN6_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN6_INT_TYPE: u32 = 7;
pub const GPIO_PIN6_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN6_DRIVER: u32 = 4;
pub const GPIO_PIN6_DRIVER_S: u32 = 2;
pub const GPIO_PIN6_SOURCE: u32 = 1;
pub const GPIO_PIN6_SOURCE_S: u32 = 0;
pub const GPIO_PIN7_ADDRESS: u32 = 68;
pub const GPIO_PIN7_CONFIG: u32 = 3;
pub const GPIO_PIN7_CONFIG_S: u32 = 11;
pub const GPIO_PIN7_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN7_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN7_INT_TYPE: u32 = 7;
pub const GPIO_PIN7_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN7_DRIVER: u32 = 4;
pub const GPIO_PIN7_DRIVER_S: u32 = 2;
pub const GPIO_PIN7_SOURCE: u32 = 1;
pub const GPIO_PIN7_SOURCE_S: u32 = 0;
pub const GPIO_PIN8_ADDRESS: u32 = 72;
pub const GPIO_PIN8_CONFIG: u32 = 3;
pub const GPIO_PIN8_CONFIG_S: u32 = 11;
pub const GPIO_PIN8_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN8_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN8_INT_TYPE: u32 = 7;
pub const GPIO_PIN8_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN8_DRIVER: u32 = 4;
pub const GPIO_PIN8_DRIVER_S: u32 = 2;
pub const GPIO_PIN8_SOURCE: u32 = 1;
pub const GPIO_PIN8_SOURCE_S: u32 = 0;
pub const GPIO_PIN9_ADDRESS: u32 = 76;
pub const GPIO_PIN9_CONFIG: u32 = 3;
pub const GPIO_PIN9_CONFIG_S: u32 = 11;
pub const GPIO_PIN9_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN9_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN9_INT_TYPE: u32 = 7;
pub const GPIO_PIN9_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN9_DRIVER: u32 = 4;
pub const GPIO_PIN9_DRIVER_S: u32 = 2;
pub const GPIO_PIN9_SOURCE: u32 = 1;
pub const GPIO_PIN9_SOURCE_S: u32 = 0;
pub const GPIO_PIN10_ADDRESS: u32 = 80;
pub const GPIO_PIN10_CONFIG: u32 = 3;
pub const GPIO_PIN10_CONFIG_S: u32 = 11;
pub const GPIO_PIN10_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN10_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN10_INT_TYPE: u32 = 7;
pub const GPIO_PIN10_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN10_DRIVER: u32 = 4;
pub const GPIO_PIN10_DRIVER_S: u32 = 2;
pub const GPIO_PIN10_SOURCE: u32 = 1;
pub const GPIO_PIN10_SOURCE_S: u32 = 0;
pub const GPIO_PIN11_ADDRESS: u32 = 84;
pub const GPIO_PIN11_CONFIG: u32 = 3;
pub const GPIO_PIN11_CONFIG_S: u32 = 11;
pub const GPIO_PIN11_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN11_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN11_INT_TYPE: u32 = 7;
pub const GPIO_PIN11_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN11_DRIVER: u32 = 4;
pub const GPIO_PIN11_DRIVER_S: u32 = 2;
pub const GPIO_PIN11_SOURCE: u32 = 1;
pub const GPIO_PIN11_SOURCE_S: u32 = 0;
pub const GPIO_PIN12_ADDRESS: u32 = 88;
pub const GPIO_PIN12_CONFIG: u32 = 3;
pub const GPIO_PIN12_CONFIG_S: u32 = 11;
pub const GPIO_PIN12_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN12_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN12_INT_TYPE: u32 = 7;
pub const GPIO_PIN12_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN12_DRIVER: u32 = 4;
pub const GPIO_PIN12_DRIVER_S: u32 = 2;
pub const GPIO_PIN12_SOURCE: u32 = 1;
pub const GPIO_PIN12_SOURCE_S: u32 = 0;
pub const GPIO_PIN13_ADDRESS: u32 = 92;
pub const GPIO_PIN13_CONFIG: u32 = 3;
pub const GPIO_PIN13_CONFIG_S: u32 = 11;
pub const GPIO_PIN13_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN13_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN13_INT_TYPE: u32 = 7;
pub const GPIO_PIN13_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN13_DRIVER: u32 = 4;
pub const GPIO_PIN13_DRIVER_S: u32 = 2;
pub const GPIO_PIN13_SOURCE: u32 = 1;
pub const GPIO_PIN13_SOURCE_S: u32 = 0;
pub const GPIO_PIN14_ADDRESS: u32 = 96;
pub const GPIO_PIN14_CONFIG: u32 = 3;
pub const GPIO_PIN14_CONFIG_S: u32 = 11;
pub const GPIO_PIN14_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN14_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN14_INT_TYPE: u32 = 7;
pub const GPIO_PIN14_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN14_DRIVER: u32 = 4;
pub const GPIO_PIN14_DRIVER_S: u32 = 2;
pub const GPIO_PIN14_SOURCE: u32 = 1;
pub const GPIO_PIN14_SOURCE_S: u32 = 0;
pub const GPIO_PIN15_ADDRESS: u32 = 100;
pub const GPIO_PIN15_CONFIG: u32 = 3;
pub const GPIO_PIN15_CONFIG_S: u32 = 11;
pub const GPIO_PIN15_WAKEUP_ENABLE: u32 = 1024;
pub const GPIO_PIN15_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN15_INT_TYPE: u32 = 7;
pub const GPIO_PIN15_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN15_DRIVER: u32 = 4;
pub const GPIO_PIN15_DRIVER_S: u32 = 2;
pub const GPIO_PIN15_SOURCE: u32 = 1;
pub const GPIO_PIN15_SOURCE_S: u32 = 0;
pub const GPIO_SIGMA_DELTA_ADDRESS: u32 = 104;
pub const SIGMA_DELTA_ENABLE: u32 = 65536;
pub const SIGMA_DELTA_ENABLE_S: u32 = 16;
pub const SIGMA_DELTA_PRESCALAR: u32 = 255;
pub const SIGMA_DELTA_PRESCALAR_S: u32 = 8;
pub const SIGMA_DELTA_TARGET: u32 = 255;
pub const SIGMA_DELTA_TARGET_S: u32 = 0;
pub const GPIO_RTC_CALIB_SYNC_ADDRESS: u32 = 108;
pub const RTC_CALIB_START: u32 = 2147483648;
pub const RTC_CALIB_START_S: u32 = 31;
pub const RTC_PERIOD_NUM: u32 = 1023;
pub const RTC_PERIOD_NUM_S: u32 = 0;
pub const GPIO_RTC_CALIB_VALUE_ADDRESS: u32 = 112;
pub const RTC_CALIB_RDY: u32 = 2147483648;
pub const RTC_CALIB_RDY_S: u32 = 31;
pub const RTC_CALIB_RDY_REAL: u32 = 1073741824;
pub const RTC_CALIB_RDY_REAL_S: u32 = 30;
pub const RTC_CALIB_VALUE: u32 = 1048575;
pub const RTC_CALIB_VALUE_S: u32 = 0;
pub const GPIO_Pin_All: u32 = 131071;
pub const GPIO_MODE_DEF_DISABLE: u32 = 0;
pub const GPIO_PIN_COUNT: u32 = 17;
pub type size_t = ::std::os::raw::c_uint;
pub type wchar_t = ::std::os::raw::c_uchar;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_longlong;
pub type __u_quad_t = ::std::os::raw::c_ulonglong;
pub type __intmax_t = ::std::os::raw::c_longlong;
pub type __uintmax_t = ::std::os::raw::c_ulonglong;
pub type __dev_t = __uint64_t;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = __uint64_t;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_uint;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = __int64_t;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = __uint64_t;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = __int64_t;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = __int64_t;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = __uint64_t;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = __uint64_t;
pub type __fsword_t = ::std::os::raw::c_int;
pub type __ssize_t = ::std::os::raw::c_int;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_int;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type __time64_t = __int64_t;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 32usize],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 32usize],
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __kind: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: __pthread_mutex_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_mutex_s__bindgen_ty_1 {
    pub __elision_data: __pthread_mutex_s__bindgen_ty_1__bindgen_ty_1,
    pub __list: __pthread_slist_t,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s__bindgen_ty_1__bindgen_ty_1 {
    pub __espins: ::std::os::raw::c_short,
    pub __eelision: ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __flags: ::std::os::raw::c_uchar,
    pub __shared: ::std::os::raw::c_uchar,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad2: ::std::os::raw::c_uchar,
    pub __cur_writer: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 36usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u32; 9usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 24usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u32; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u32; 2usize],
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 20usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u32; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_uint) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_uint,
        __size: ::std::os::raw::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::core::ffi::c_void,
        __size: ::std::os::raw::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::core::ffi::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_uint) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::core::ffi::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(__status: ::std::os::raw::c_int, __arg: *mut ::core::ffi::c_void),
        >,
        __arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::core::ffi::c_void,
        __base: *const ::core::ffi::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::core::ffi::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type esp_tick_t = u32;
pub type esp_irqflag_t = u32;
pub const STATUS_OK: STATUS = 0;
pub const STATUS_FAIL: STATUS = 1;
pub const STATUS_PENDING: STATUS = 2;
pub const STATUS_BUSY: STATUS = 3;
pub const STATUS_CANCEL: STATUS = 4;
pub type STATUS = ::std::os::raw::c_uint;
extern "C" {
    pub fn vPortETSIntrLock();
}
extern "C" {
    pub fn vPortETSIntrUnlock();
}
pub type ETSSignal = u32;
pub type ETSParam = u32;
pub type ETSEvent = ETSEventTag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ETSEventTag {
    #[doc = "< Event signal, in same task, different Event with different signal"]
    pub sig: ETSSignal,
    #[doc = "< Event parameter, sometimes without usage, then will be set as 0"]
    pub par: ETSParam,
}
extern "C" {
    #[doc = " @brief  Delay function, maximum value: 65535 us."]
    #[doc = ""]
    #[doc = " @param  uint16_t us : delay time, uint: us, maximum value: 65535 us"]
    #[doc = ""]
    #[doc = " @return null"]
    pub fn os_delay_us(us: u16);
}
extern "C" {
    #[doc = " @brief  CPU do while loop for some time."]
    #[doc = "         In FreeRTOS task, please call FreeRTOS apis."]
    #[doc = ""]
    #[doc = " @param  uint32_t us : Delay time in us."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_delay_us(us: u32);
}
extern "C" {
    #[doc = " @brief  Printf the strings to uart or other devices, similar with printf, simple than printf."]
    #[doc = "         Can not print float point data format, or longlong data format."]
    #[doc = ""]
    #[doc = " @param  const char *fmt : See printf."]
    #[doc = ""]
    #[doc = " @param  ... : See printf."]
    #[doc = ""]
    #[doc = " @return int : the length printed to the output device."]
    pub fn ets_printf(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief     Register the print output function."]
    #[doc = ""]
    #[doc = " @attention os_install_putc1((void *)uart1_write_char) in uart_init will set"]
    #[doc = "            printf to print from UART 1, otherwise, printf will start from"]
    #[doc = "            UART 0 by default."]
    #[doc = ""]
    #[doc = " @param     void(*p)(char c) - pointer of print function"]
    #[doc = ""]
    #[doc = " @return    null"]
    pub fn os_install_putc1(
        p: ::core::option::Option<unsafe extern "C" fn(c: ::std::os::raw::c_char)>,
    );
}
extern "C" {
    #[doc = " @brief  Print a character. Start from from UART0 by default."]
    #[doc = ""]
    #[doc = " @param  char c - character to be printed"]
    #[doc = ""]
    #[doc = " @return null"]
    pub fn os_putc(c: ::std::os::raw::c_char);
}
pub type os_timer_func_t =
    ::core::option::Option<unsafe extern "C" fn(timer_arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _os_timer_t {
    pub timer_next: *mut _os_timer_t,
    pub timer_handle: *mut ::core::ffi::c_void,
    pub timer_expire: u32,
    pub timer_period: u32,
    pub timer_func: os_timer_func_t,
    pub timer_repeat_flag: bool,
    pub timer_arg: *mut ::core::ffi::c_void,
}
pub type os_timer_t = _os_timer_t;
extern "C" {
    #[doc = " @brief     Set the timer callback function."]
    #[doc = ""]
    #[doc = " @attention 1. The callback function must be set in order to enable the timer."]
    #[doc = " @attention 2. Operating system scheduling is disabled in timer callback."]
    #[doc = ""]
    #[doc = " @param     os_timer_t *ptimer : Timer structure"]
    #[doc = " @param     os_timer_func_t *pfunction : timer callback function"]
    #[doc = " @param     void *parg : callback function parameter"]
    #[doc = ""]
    #[doc = " @return    null"]
    pub fn os_timer_setfn(
        ptimer: *mut os_timer_t,
        pfunction: os_timer_func_t,
        parg: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief  Enable the millisecond timer."]
    #[doc = ""]
    #[doc = " @param  os_timer_t *ptimer : timer structure"]
    #[doc = " @param  uint32_t milliseconds : Timing, unit: millisecond, range: 5 ~ 0x68DB8"]
    #[doc = " @param  bool repeat_flag : Whether the timer will be invoked repeatedly or not"]
    #[doc = ""]
    #[doc = " @return null"]
    pub fn os_timer_arm(ptimer: *mut os_timer_t, msec: u32, repeat_flag: bool);
}
extern "C" {
    #[doc = " @brief  Disarm the timer"]
    #[doc = ""]
    #[doc = " @param  os_timer_t *ptimer : Timer structure"]
    #[doc = ""]
    #[doc = " @return null"]
    pub fn os_timer_disarm(ptimer: *mut os_timer_t);
}
extern "C" {
    pub fn ets_timer_done(ptimer: *mut os_timer_t);
}
pub type TaskFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
extern "C" {
    pub static Xthal_rev_no: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_save_extra(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_extra(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cpregs(base: *mut ::core::ffi::c_void, arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xthal_restore_cpregs(base: *mut ::core::ffi::c_void, arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xthal_save_cp0(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cp1(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cp2(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cp3(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cp4(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cp5(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cp6(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cp7(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp0(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp1(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp2(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp3(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp4(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp5(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp6(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp7(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub static mut Xthal_cpregs_save_fn: [*mut ::core::ffi::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_restore_fn: [*mut ::core::ffi::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_save_nw_fn: [*mut ::core::ffi::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_restore_nw_fn: [*mut ::core::ffi::c_void; 8usize];
}
extern "C" {
    pub static Xthal_extra_size: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_extra_align: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cpregs_size: [::std::os::raw::c_uint; 8usize];
}
extern "C" {
    pub static Xthal_cpregs_align: [::std::os::raw::c_uint; 8usize];
}
extern "C" {
    pub static Xthal_all_extra_size: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_all_extra_align: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_names: [*const ::std::os::raw::c_char; 8usize];
}
extern "C" {
    pub fn xthal_init_mem_extra(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_init_mem_cp(arg1: *mut ::core::ffi::c_void, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub static Xthal_num_coprocessors: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_num: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_max: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_num_aregs: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_num_aregs_log2: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_icache_linewidth: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_linewidth: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_icache_linesize: ::std::os::raw::c_ushort;
}
extern "C" {
    pub static Xthal_dcache_linesize: ::std::os::raw::c_ushort;
}
extern "C" {
    pub static Xthal_icache_size: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_dcache_size: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_dcache_is_writeback: ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn xthal_icache_region_invalidate(
        addr: *mut ::core::ffi::c_void,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn xthal_dcache_region_invalidate(
        addr: *mut ::core::ffi::c_void,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn xthal_icache_line_invalidate(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_invalidate(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_dcache_region_writeback(
        addr: *mut ::core::ffi::c_void,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn xthal_dcache_line_writeback(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_dcache_region_writeback_inv(
        addr: *mut ::core::ffi::c_void,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn xthal_dcache_line_writeback_inv(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_icache_sync();
}
extern "C" {
    pub fn xthal_dcache_sync();
}
extern "C" {
    pub fn xthal_cache_coherence_on();
}
extern "C" {
    pub fn xthal_cache_coherence_off();
}
extern "C" {
    pub fn xthal_cache_coherence_optin();
}
extern "C" {
    pub fn xthal_cache_coherence_optout();
}
extern "C" {
    pub fn xthal_set_cache_prefetch(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_get_cache_prefetch() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_debug_configured: ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_soft_break(addr: *mut ::core::ffi::c_void) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_remove_soft_break(addr: *mut ::core::ffi::c_void, arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_disassemble(
        instr_buf: *mut ::std::os::raw::c_uchar,
        tgt_addr: *mut ::core::ffi::c_void,
        buffer: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_uint,
        options: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_disassemble_size(instr_buf: *mut ::std::os::raw::c_uchar)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_memcpy(
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        len: ::std::os::raw::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn xthal_bcopy(
        src: *const ::core::ffi::c_void,
        dst: *mut ::core::ffi::c_void,
        len: ::std::os::raw::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn xthal_compare_and_set(
        addr: *mut ::std::os::raw::c_int,
        test_val: ::std::os::raw::c_int,
        compare_val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_release_major: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_release_minor: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_release_name: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static Xthal_release_internal: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static Xthal_memory_order: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_windowed: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_density: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_booleans: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_loops: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_nsa: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_minmax: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_sext: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_clamps: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_mac16: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_mul16: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_fp: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_speculation: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_threadptr: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_pif: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_writebuffer_entries: ::std::os::raw::c_ushort;
}
extern "C" {
    pub static Xthal_build_unique_id: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_hw_configid0: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_hw_configid1: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_major: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_minor: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_name: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static Xthal_hw_release_internal: *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn xthal_window_spill();
}
extern "C" {
    pub fn xthal_validate_cp(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xthal_invalidate_cp(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xthal_set_cpenable(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_get_cpenable() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_num_intlevels: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_interrupts: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_intlevel_mask: [::std::os::raw::c_uint; 16usize];
}
extern "C" {
    pub static Xthal_intlevel_andbelow_mask: [::std::os::raw::c_uint; 16usize];
}
extern "C" {
    pub static Xthal_intlevel: [::std::os::raw::c_uchar; 32usize];
}
extern "C" {
    pub static Xthal_inttype: [::std::os::raw::c_uchar; 32usize];
}
extern "C" {
    pub static Xthal_inttype_mask: [::std::os::raw::c_uint; 7usize];
}
extern "C" {
    pub static Xthal_timer_interrupt: [::std::os::raw::c_int; 4usize];
}
extern "C" {
    pub fn xthal_get_intenable() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_intenable(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_get_interrupt() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_intset(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_set_intclear(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub static Xthal_num_ibreak: ::std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_num_dbreak: ::std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_have_ccount: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_ccompare: ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn xthal_get_ccount() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_ccompare(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_get_ccompare(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_have_prid: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_exceptions: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_xea_version: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_interrupts: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_highlevel_interrupts: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_nmi: ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn xthal_get_prid() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_vpri_to_intlevel(vpri: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_intlevel_to_vpri(intlevel: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_int_enable(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_int_disable(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_int_vpri(
        intnum: ::std::os::raw::c_int,
        vpri: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_get_int_vpri(intnum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_vpri_locklevel(intlevel: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_get_vpri_locklevel() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri(vpri: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_get_vpri() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri_intlevel(intlevel: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri_lock() -> ::std::os::raw::c_uint;
}
pub type XtHalVoidFunc = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut Xthal_tram_pending: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut Xthal_tram_enabled: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut Xthal_tram_sync: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_tram_pending_to_service() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_tram_done(serviced_mask: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_tram_set_sync(
        intnum: ::std::os::raw::c_int,
        sync: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_tram_trigger_func(trigger_fn: XtHalVoidFunc) -> XtHalVoidFunc;
}
extern "C" {
    pub static Xthal_num_instrom: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_instram: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_datarom: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_dataram: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_xlmi: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static mut Xthal_instrom_vaddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instrom_paddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instrom_size: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_vaddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_paddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_size: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_vaddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_paddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_size: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_vaddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_paddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_size: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_vaddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_paddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_size: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static Xthal_icache_setwidth: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_setwidth: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_icache_ways: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_dcache_ways: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_icache_line_lockable: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_line_lockable: ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn xthal_get_cacheattr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_get_icacheattr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_get_dcacheattr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_cacheattr(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_set_icacheattr(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_set_dcacheattr(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_set_region_attribute(
        addr: *mut ::core::ffi::c_void,
        size: ::std::os::raw::c_uint,
        cattr: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_icache_enable();
}
extern "C" {
    pub fn xthal_dcache_enable();
}
extern "C" {
    pub fn xthal_icache_disable();
}
extern "C" {
    pub fn xthal_dcache_disable();
}
extern "C" {
    pub fn xthal_icache_all_invalidate();
}
extern "C" {
    pub fn xthal_dcache_all_invalidate();
}
extern "C" {
    pub fn xthal_dcache_all_writeback();
}
extern "C" {
    pub fn xthal_dcache_all_writeback_inv();
}
extern "C" {
    pub fn xthal_icache_region_lock(addr: *mut ::core::ffi::c_void, size: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_lock(addr: *mut ::core::ffi::c_void, size: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_icache_line_lock(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_lock(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_icache_all_unlock();
}
extern "C" {
    pub fn xthal_dcache_all_unlock();
}
extern "C" {
    pub fn xthal_icache_region_unlock(addr: *mut ::core::ffi::c_void, size: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_unlock(addr: *mut ::core::ffi::c_void, size: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_icache_line_unlock(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_unlock(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_memep_inject_error(
        addr: *mut ::core::ffi::c_void,
        size: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub static Xthal_have_spanning_way: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_identity_map: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_mimic_cacheattr: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_xlt_cacheattr: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_cacheattr: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_tlbs: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_asid_bits: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_asid_kernel: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_rings: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_ring_bits: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_sr_bits: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_ca_bits: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_max_pte_page_size: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_mmu_min_pte_page_size: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_itlb_way_bits: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_itlb_ways: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_itlb_arf_ways: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_way_bits: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_ways: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_arf_ways: ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " WARNING: these two functions may go away in a future release; don't depend on them!"]
    pub fn xthal_static_v2p(
        vaddr: ::std::os::raw::c_uint,
        paddrp: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_static_p2v(
        paddr: ::std::os::raw::c_uint,
        vaddrp: *mut ::std::os::raw::c_uint,
        cached: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP0_IDENT: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP0_IDENT: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP1_IDENT: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP1_IDENT: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP2_IDENT: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP2_IDENT: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP3_IDENT: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP3_IDENT: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP4_IDENT: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP4_IDENT: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP5_IDENT: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP5_IDENT: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP6_IDENT: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP6_IDENT: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP7_IDENT: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP7_IDENT: ::std::os::raw::c_uint;
}
pub type _xtos_handler_func = ::core::option::Option<unsafe extern "C" fn()>;
pub type _xtos_handler = _xtos_handler_func;
extern "C" {
    pub fn _xtos_ints_off(mask: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_ints_on(mask: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_set_intlevel(intlevel: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_set_min_intlevel(intlevel: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_restore_intlevel(restoreval: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_restore_just_intlevel(
        restoreval: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_set_interrupt_handler(n: ::std::os::raw::c_int, f: _xtos_handler)
        -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_set_interrupt_handler_arg(
        n: ::std::os::raw::c_int,
        f: _xtos_handler,
        arg: *mut ::core::ffi::c_void,
    ) -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_set_exception_handler(n: ::std::os::raw::c_int, f: _xtos_handler)
        -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_memep_initrams();
}
extern "C" {
    pub fn _xtos_memep_enable(flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _xtos_read_ints() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_clear_ints(mask: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _xtos_timer_0_delta(cycles: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _xt_int_enter();
}
extern "C" {
    pub fn _xt_int_exit();
}
extern "C" {
    pub fn _xt_timer_int();
}
pub type XT_INTEXC_HOOK = ::core::option::Option<
    unsafe extern "C" fn(cause: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint,
>;
extern "C" {
    pub static mut _xt_intexc_hooks: [XT_INTEXC_HOOK; 4usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KernelFrame {
    pub pc: ::std::os::raw::c_long,
    pub ps: ::std::os::raw::c_long,
    pub areg: [::std::os::raw::c_long; 4usize],
    pub sar: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserFrame {
    pub pc: ::std::os::raw::c_long,
    pub ps: ::std::os::raw::c_long,
    pub sar: ::std::os::raw::c_long,
    pub vpri: ::std::os::raw::c_long,
    pub a2: ::std::os::raw::c_long,
    pub a3: ::std::os::raw::c_long,
    pub a4: ::std::os::raw::c_long,
    pub a5: ::std::os::raw::c_long,
    pub exccause: ::std::os::raw::c_long,
    pub pad: [::std::os::raw::c_long; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XtExcFrame {
    pub exit: ::std::os::raw::c_long,
    pub pc: ::std::os::raw::c_long,
    pub ps: ::std::os::raw::c_long,
    pub a0: ::std::os::raw::c_long,
    pub a1: ::std::os::raw::c_long,
    pub a2: ::std::os::raw::c_long,
    pub a3: ::std::os::raw::c_long,
    pub a4: ::std::os::raw::c_long,
    pub a5: ::std::os::raw::c_long,
    pub a6: ::std::os::raw::c_long,
    pub a7: ::std::os::raw::c_long,
    pub a8: ::std::os::raw::c_long,
    pub a9: ::std::os::raw::c_long,
    pub a10: ::std::os::raw::c_long,
    pub a11: ::std::os::raw::c_long,
    pub a12: ::std::os::raw::c_long,
    pub a13: ::std::os::raw::c_long,
    pub a14: ::std::os::raw::c_long,
    pub a15: ::std::os::raw::c_long,
    pub sar: ::std::os::raw::c_long,
    pub exccause: ::std::os::raw::c_long,
    pub excvaddr: ::std::os::raw::c_long,
    pub tmp0: ::std::os::raw::c_long,
    pub tmp1: ::std::os::raw::c_long,
    pub tmp2: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XtSolFrame {
    pub exit: ::std::os::raw::c_long,
    pub pc: ::std::os::raw::c_long,
    pub ps: ::std::os::raw::c_long,
    pub next: ::std::os::raw::c_long,
    pub a0: ::std::os::raw::c_long,
    pub a1: ::std::os::raw::c_long,
    pub a2: ::std::os::raw::c_long,
    pub a3: ::std::os::raw::c_long,
}
extern "C" {
    pub static mut _xt_tick_divisor: ::std::os::raw::c_uint;
}
pub type StackType_t = u8;
pub type BaseType_t = ::std::os::raw::c_int;
pub type UBaseType_t = ::std::os::raw::c_uint;
pub type TickType_t = u32;
extern "C" {
    pub fn PendSV(req: ::std::os::raw::c_int);
}
extern "C" {
    pub fn portYIELD_FROM_ISR();
}
extern "C" {
    pub static mut cpu_sr: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn vPortEnterCritical();
}
extern "C" {
    pub fn vPortExitCritical();
}
extern "C" {
    pub fn PortDisableInt_NoNest();
}
extern "C" {
    pub fn PortEnableInt_NoNest();
}
extern "C" {
    pub fn _xt_user_exit();
}
extern "C" {
    pub fn _xt_tick_timer_init();
}
extern "C" {
    pub fn _xt_isr_unmask(unmask: u32);
}
extern "C" {
    pub fn _xt_isr_mask(mask: u32);
}
pub type _xt_isr = ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
extern "C" {
    pub fn _xt_isr_attach(i: u8, func: _xt_isr, arg: *mut ::core::ffi::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xt_isr_entry_ {
    pub handler: _xt_isr,
    pub arg: *mut ::core::ffi::c_void,
}
pub type _xt_isr_entry = _xt_isr_entry_;
extern "C" {
    pub fn show_critical_info();
}
extern "C" {
    pub fn esp_mem_trace(
        ptr: *const ::core::ffi::c_void,
        trace: *const ::std::os::raw::c_char,
        no: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn interrupt_is_disable() -> bool;
}
extern "C" {
    pub fn xPortGetTickRateHz() -> u32;
}
extern "C" {
    pub fn _xt_enter_first_task();
}
extern "C" {
    pub fn esp_increase_tick_cnt(ticks: TickType_t);
}
extern "C" {
    pub fn esp_vApplicationIdleHook();
}
extern "C" {
    pub fn esp_vApplicationTickHook();
}
extern "C" {
    pub static mut g_esp_ticks_per_us: u32;
}
extern "C" {
    pub fn prvGetExpectedIdleTime() -> TickType_t;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::core::ffi::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::core::ffi::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 40usize],
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::core::ffi::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_uint,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_uint,
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::core::ffi::c_void,
        __size: ::std::os::raw::c_uint,
        __n: ::std::os::raw::c_uint,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::core::ffi::c_void,
        __size: ::std::os::raw::c_uint,
        __n: ::std::os::raw::c_uint,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::core::ffi::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::core::ffi::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    );
}
pub type esp_err_t = i32;
extern "C" {
    #[doc = " @brief Returns string for esp_err_t error codes"]
    #[doc = ""]
    #[doc = " This function finds the error code in a pre-generated lookup-table and"]
    #[doc = " returns its string representation."]
    #[doc = ""]
    #[doc = " The function is generated by the Python script"]
    #[doc = " tools/gen_esp_err_to_name.py which should be run each time an esp_err_t"]
    #[doc = " error is modified, created or removed from the IDF project."]
    #[doc = ""]
    #[doc = " @param code esp_err_t error code"]
    #[doc = " @return string error message"]
    pub fn esp_err_to_name(code: esp_err_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns string for esp_err_t and system error codes"]
    #[doc = ""]
    #[doc = " This function finds the error code in a pre-generated lookup-table of"]
    #[doc = " esp_err_t errors and returns its string representation. If the error code"]
    #[doc = " is not found then it is attempted to be found among system errors."]
    #[doc = ""]
    #[doc = " The function is generated by the Python script"]
    #[doc = " tools/gen_esp_err_to_name.py which should be run each time an esp_err_t"]
    #[doc = " error is modified, created or removed from the IDF project."]
    #[doc = ""]
    #[doc = " @param code esp_err_t error code"]
    #[doc = " @param[out] buf buffer where the error message should be written"]
    #[doc = " @param buflen Size of buffer buf. At most buflen bytes are written into the buf buffer (including the terminating null byte)."]
    #[doc = " @return buf containing the string error message"]
    pub fn esp_err_to_name_r(
        code: esp_err_t,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed(
        rc: esp_err_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed_without_abort(
        rc: esp_err_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
#[doc = " First type memory block."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_blk {
    #[doc = "< Point to previous memory block"]
    pub prev: *mut mem_blk,
    #[doc = "< Point to next memory block"]
    pub next: *mut mem_blk,
}
#[doc = " First type memory block."]
pub type mem_blk_t = mem_blk;
pub type mem2_blk_t = mem_blk_t;
#[doc = " User region information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct heap_region {
    #[doc = "< Heap region start address"]
    pub start_addr: *mut ::core::ffi::c_void,
    #[doc = "< Heap region total size by byte"]
    pub total_size: size_t,
    #[doc = "< Heap capacity"]
    pub caps: u32,
    #[doc = "< First free memory block"]
    pub free_blk: *mut ::core::ffi::c_void,
    #[doc = "< Current free heap size by byte"]
    pub free_bytes: size_t,
    #[doc = "< Minimum free heap size by byte ever"]
    pub min_free_bytes: size_t,
}
#[doc = " User region information."]
pub type heap_region_t = heap_region;
extern "C" {
    #[doc = " @brief Get the total free size of all the regions that have the given capabilities"]
    #[doc = ""]
    #[doc = " This function takes all regions capable of having the given capabilities allocated in them"]
    #[doc = " and adds up the free space they have."]
    #[doc = ""]
    #[doc = " @param caps Bitwise OR of MALLOC_CAP_* flags indicating the type of memory"]
    #[doc = ""]
    #[doc = " @return Amount of free bytes in the regions"]
    pub fn heap_caps_get_free_size(caps: u32) -> size_t;
}
extern "C" {
    #[doc = " @brief Get the total minimum free memory of all regions with the given capabilities"]
    #[doc = ""]
    #[doc = " This adds all the low water marks of the regions capable of delivering the memory"]
    #[doc = " with the given capabilities."]
    #[doc = ""]
    #[doc = " @param caps Bitwise OR of MALLOC_CAP_* flags indicating the type of memory"]
    #[doc = ""]
    #[doc = " @return Amount of free bytes in the regions"]
    pub fn heap_caps_get_minimum_free_size(caps: u32) -> size_t;
}
extern "C" {
    #[doc = " @brief Initialize regions of memory to the collection of heaps at runtime."]
    #[doc = ""]
    #[doc = " @param region region table head point"]
    #[doc = " @param max_num region table size"]
    pub fn esp_heap_caps_init_region(region: *mut heap_region_t, max_num: size_t);
}
extern "C" {
    pub fn _heap_caps_malloc(
        size: size_t,
        caps: u32,
        file: *const ::std::os::raw::c_char,
        line: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _heap_caps_free(
        ptr: *mut ::core::ffi::c_void,
        file: *const ::std::os::raw::c_char,
        line: size_t,
    );
}
extern "C" {
    pub fn _heap_caps_calloc(
        count: size_t,
        size: size_t,
        caps: u32,
        file: *const ::std::os::raw::c_char,
        line: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _heap_caps_realloc(
        mem: *mut ::core::ffi::c_void,
        newsize: size_t,
        caps: u32,
        file: *const ::std::os::raw::c_char,
        line: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _heap_caps_zalloc(
        size: size_t,
        caps: u32,
        file: *const ::std::os::raw::c_char,
        line: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut StackType_t,
        pxCode: TaskFunction_t,
        pvParameters: *mut ::core::ffi::c_void,
    ) -> *mut StackType_t;
}
extern "C" {
    pub fn xPortStartScheduler() -> BaseType_t;
}
extern "C" {
    pub fn vPortEndScheduler();
}
extern "C" {
    pub fn xPortInIsrContext() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Copy thread context from old thread stack to new thread stack and"]
    #[doc = "        then reset the SP."]
    #[doc = ""]
    #[doc = " @param newStackTop new thread stack pointer"]
    #[doc = " @param oldStackTop old thread stack pointer"]
    #[doc = " @param stackSize   stack size"]
    pub fn vPortInitContextFromOldStack(
        newStackTop: *mut StackType_t,
        oldStackTop: *mut StackType_t,
        stackSize: UBaseType_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST_ITEM {
    pub xDummy1: TickType_t,
    pub pvDummy2: [*mut ::core::ffi::c_void; 4usize],
}
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_MINI_LIST_ITEM {
    pub xDummy1: TickType_t,
    pub pvDummy2: [*mut ::core::ffi::c_void; 2usize],
}
pub type StaticMiniListItem_t = xSTATIC_MINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST {
    pub uxDummy1: UBaseType_t,
    pub pvDummy2: *mut ::core::ffi::c_void,
    pub xDummy3: StaticMiniListItem_t,
}
pub type StaticList_t = xSTATIC_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TCB {
    pub pxDummy1: *mut ::core::ffi::c_void,
    pub xDummy3: [StaticListItem_t; 2usize],
    pub uxDummy5: UBaseType_t,
    pub pxDummy6: *mut ::core::ffi::c_void,
    pub ucDummy7: [u8; 16usize],
    pub pxDummy8: *mut ::core::ffi::c_void,
    pub uxDummy12: [UBaseType_t; 2usize],
    pub pvDummy15: [*mut ::core::ffi::c_void; 3usize],
    pub ulDummy18: u32,
    pub ucDummy19: u8,
}
pub type StaticTask_t = xSTATIC_TCB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xSTATIC_QUEUE {
    pub pvDummy1: [*mut ::core::ffi::c_void; 3usize],
    pub u: xSTATIC_QUEUE__bindgen_ty_1,
    pub xDummy3: [StaticList_t; 2usize],
    pub uxDummy4: [UBaseType_t; 3usize],
    pub ucDummy5: [u8; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xSTATIC_QUEUE__bindgen_ty_1 {
    pub pvDummy2: *mut ::core::ffi::c_void,
    pub uxDummy2: UBaseType_t,
    _bindgen_union_align: u32,
}
pub type StaticQueue_t = xSTATIC_QUEUE;
pub type StaticSemaphore_t = StaticQueue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_EVENT_GROUP {
    pub xDummy1: TickType_t,
    pub xDummy2: StaticList_t,
}
pub type StaticEventGroup_t = xSTATIC_EVENT_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TIMER {
    pub pvDummy1: *mut ::core::ffi::c_void,
    pub xDummy2: StaticListItem_t,
    pub xDummy3: TickType_t,
    pub uxDummy4: UBaseType_t,
    pub pvDummy5: [*mut ::core::ffi::c_void; 2usize],
}
pub type StaticTimer_t = xSTATIC_TIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_STREAM_BUFFER {
    pub uxDummy1: [size_t; 4usize],
    pub pvDummy2: [*mut ::core::ffi::c_void; 3usize],
    pub ucDummy3: u8,
}
pub type StaticStreamBuffer_t = xSTATIC_STREAM_BUFFER;
pub type StaticMessageBuffer_t = StaticStreamBuffer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
    pub pvOwner: *mut ::core::ffi::c_void,
    pub pvContainer: *mut ::core::ffi::c_void,
}
pub type ListItem_t = xLIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMINI_LIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
}
pub type MiniListItem_t = xMINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST {
    pub uxNumberOfItems: UBaseType_t,
    pub pxIndex: *mut ListItem_t,
    pub xListEnd: MiniListItem_t,
}
pub type List_t = xLIST;
extern "C" {
    pub fn vListInitialise(pxList: *mut List_t);
}
extern "C" {
    pub fn vListInitialiseItem(pxItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsert(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsertEnd(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn uxListRemove(pxItemToRemove: *mut ListItem_t) -> UBaseType_t;
}
#[doc = " task. h"]
#[doc = ""]
#[doc = " Type by which tasks are referenced.  For example, a call to xTaskCreate"]
#[doc = " returns (via a pointer parameter) an TaskHandle_t variable that can then"]
#[doc = " be used as a parameter to vTaskDelete to delete the task."]
#[doc = ""]
#[doc = " \\defgroup TaskHandle_t TaskHandle_t"]
#[doc = " \\ingroup Tasks"]
pub type TaskHandle_t = *mut ::core::ffi::c_void;
pub type TaskHookFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> BaseType_t>;
pub const eTaskState_eRunning: eTaskState = 0;
pub const eTaskState_eReady: eTaskState = 1;
pub const eTaskState_eBlocked: eTaskState = 2;
pub const eTaskState_eSuspended: eTaskState = 3;
pub const eTaskState_eDeleted: eTaskState = 4;
pub const eTaskState_eInvalid: eTaskState = 5;
pub type eTaskState = ::std::os::raw::c_uint;
pub const eNotifyAction_eNoAction: eNotifyAction = 0;
pub const eNotifyAction_eSetBits: eNotifyAction = 1;
pub const eNotifyAction_eIncrement: eNotifyAction = 2;
pub const eNotifyAction_eSetValueWithOverwrite: eNotifyAction = 3;
pub const eNotifyAction_eSetValueWithoutOverwrite: eNotifyAction = 4;
pub type eNotifyAction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTIME_OUT {
    pub xOverflowCount: BaseType_t,
    pub xTimeOnEntering: TickType_t,
}
pub type TimeOut_t = xTIME_OUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMEMORY_REGION {
    pub pvBaseAddress: *mut ::core::ffi::c_void,
    pub ulLengthInBytes: u32,
    pub ulParameters: u32,
}
pub type MemoryRegion_t = xMEMORY_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_PARAMETERS {
    pub pvTaskCode: TaskFunction_t,
    pub pcName: *const ::std::os::raw::c_char,
    pub usStackDepth: u16,
    pub pvParameters: *mut ::core::ffi::c_void,
    pub uxPriority: UBaseType_t,
    pub puxStackBuffer: *mut StackType_t,
    pub xRegions: [MemoryRegion_t; 1usize],
}
pub type TaskParameters_t = xTASK_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_STATUS {
    pub xHandle: TaskHandle_t,
    pub pcTaskName: *const ::std::os::raw::c_char,
    pub xTaskNumber: UBaseType_t,
    pub eCurrentState: eTaskState,
    pub uxCurrentPriority: UBaseType_t,
    pub uxBasePriority: UBaseType_t,
    pub ulRunTimeCounter: u32,
    pub pxStackBase: *mut StackType_t,
    pub usStackHighWaterMark: u16,
}
pub type TaskStatus_t = xTASK_STATUS;
pub const eSleepModeStatus_eAbortSleep: eSleepModeStatus = 0;
pub const eSleepModeStatus_eStandardSleep: eSleepModeStatus = 1;
pub const eSleepModeStatus_eNoTasksWaitingTimeout: eSleepModeStatus = 2;
pub type eSleepModeStatus = ::std::os::raw::c_uint;
extern "C" {
    pub fn xTaskCreate(
        pxTaskCode: TaskFunction_t,
        pcName: *const ::std::os::raw::c_char,
        usStackDepth: u16,
        pvParameters: *mut ::core::ffi::c_void,
        uxPriority: UBaseType_t,
        pxCreatedTask: *mut TaskHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = "<pre>"]
    #[doc = "void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</pre>"]
    #[doc = ""]
    #[doc = " Memory regions are assigned to a restricted task when the task is created by"]
    #[doc = " a call to xTaskCreateRestricted().  These regions can be redefined using"]
    #[doc = " vTaskAllocateMPURegions()."]
    #[doc = ""]
    #[doc = " @param xTask The handle of the task being updated."]
    #[doc = ""]
    #[doc = " @param xRegions A pointer to an MemoryRegion_t structure that contains the"]
    #[doc = " new memory region definitions."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] ="]
    #[doc = "{"]
    #[doc = "{ ucOneKByte,\t\t1024,\t\tportMPU_REGION_READ_WRITE },"]
    #[doc = "{ 0,\t\t\t\t0,\t\t\t0 },"]
    #[doc = "{ 0,\t\t\t\t0,\t\t\t0 }"]
    #[doc = "};"]
    #[doc = ""]
    #[doc = "void vATask( void *pvParameters )"]
    #[doc = "{"]
    #[doc = "vTaskAllocateMPURegions( NULL, xAltRegions );"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup xTaskCreateRestricted xTaskCreateRestricted"]
    #[doc = " \\ingroup Tasks"]
    pub fn vTaskAllocateMPURegions(xTask: TaskHandle_t, pxRegions: *const MemoryRegion_t);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskDelete( TaskHandle_t xTask );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskDelete must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " Remove a task from the RTOS real time kernel's management.  The task being"]
    #[doc = " deleted will be removed from all ready, blocked, suspended and event lists."]
    #[doc = ""]
    #[doc = " NOTE:  The idle task is responsible for freeing the kernel allocated"]
    #[doc = " memory from tasks that have been deleted.  It is therefore important that"]
    #[doc = " the idle task is not starved of microcontroller processing time if your"]
    #[doc = " application makes any calls to vTaskDelete ().  Memory allocated by the"]
    #[doc = " task code is not automatically freed, and should be freed before the task"]
    #[doc = " is deleted."]
    #[doc = ""]
    #[doc = " See the demo application file death.c for sample code that utilises"]
    #[doc = " vTaskDelete ()."]
    #[doc = ""]
    #[doc = " @param xTask The handle of the task to be deleted.  Passing NULL will"]
    #[doc = " cause the calling task to be deleted."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vOtherFunction( void )"]
    #[doc = "{"]
    #[doc = "TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = "vTaskDelete( xHandle );"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup vTaskDelete vTaskDelete"]
    #[doc = " \\ingroup Tasks"]
    pub fn vTaskDelete(xTaskToDelete: TaskHandle_t);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskDelay( const TickType_t xTicksToDelay );</pre>"]
    #[doc = ""]
    #[doc = " Delay a task for a given number of ticks.  The actual time that the"]
    #[doc = " task remains blocked depends on the tick rate.  The constant"]
    #[doc = " portTICK_PERIOD_MS can be used to calculate real time from the tick"]
    #[doc = " rate - with the resolution of one tick period."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskDelay must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " vTaskDelay() specifies a time at which the task wishes to unblock relative to"]
    #[doc = " the time at which vTaskDelay() is called.  For example, specifying a block"]
    #[doc = " period of 100 ticks will cause the task to unblock 100 ticks after"]
    #[doc = " vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method"]
    #[doc = " of controlling the frequency of a periodic task as the path taken through the"]
    #[doc = " code, as well as other task and interrupt activity, will effect the frequency"]
    #[doc = " at which vTaskDelay() gets called and therefore the time at which the task"]
    #[doc = " next executes.  See vTaskDelayUntil() for an alternative API function designed"]
    #[doc = " to facilitate fixed frequency execution.  It does this by specifying an"]
    #[doc = " absolute time (rather than a relative time) at which the calling task should"]
    #[doc = " unblock."]
    #[doc = ""]
    #[doc = " @param xTicksToDelay The amount of time, in tick periods, that"]
    #[doc = " the calling task should block."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = ""]
    #[doc = "void vTaskFunction( void * pvParameters )"]
    #[doc = "{"]
    #[doc = "const TickType_t xDelay = 500 / portTICK_PERIOD_MS;"]
    #[doc = ""]
    #[doc = "for( ;; )"]
    #[doc = "{"]
    #[doc = "vToggleLED();"]
    #[doc = "vTaskDelay( xDelay );"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = " \\defgroup vTaskDelay vTaskDelay"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskDelay(xTicksToDelay: TickType_t);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " Delay a task until a specified time.  This function can be used by periodic"]
    #[doc = " tasks to ensure a constant execution frequency."]
    #[doc = ""]
    #[doc = " This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will"]
    #[doc = " cause a task to block for the specified number of ticks from the time vTaskDelay () is"]
    #[doc = " called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed"]
    #[doc = " execution frequency as the time between a task starting to execute and that task"]
    #[doc = " calling vTaskDelay () may not be fixed [the task may take a different path though the"]
    #[doc = " code between calls, or may get interrupted or preempted a different number of times"]
    #[doc = " each time it executes]."]
    #[doc = ""]
    #[doc = " Whereas vTaskDelay () specifies a wake time relative to the time at which the function"]
    #[doc = " is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to"]
    #[doc = " unblock."]
    #[doc = ""]
    #[doc = " The constant portTICK_PERIOD_MS can be used to calculate real time from the tick"]
    #[doc = " rate - with the resolution of one tick period."]
    #[doc = ""]
    #[doc = " @param pxPreviousWakeTime Pointer to a variable that holds the time at which the"]
    #[doc = " task was last unblocked.  The variable must be initialised with the current time"]
    #[doc = " prior to its first use (see the example below).  Following this the variable is"]
    #[doc = " automatically updated within vTaskDelayUntil ()."]
    #[doc = ""]
    #[doc = " @param xTimeIncrement The cycle time period.  The task will be unblocked at"]
    #[doc = " time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the"]
    #[doc = " same xTimeIncrement parameter value will cause the task to execute with"]
    #[doc = " a fixed interface period."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vTaskFunction( void * pvParameters )"]
    #[doc = "{"]
    #[doc = "TickType_t xLastWakeTime;"]
    #[doc = "const TickType_t xFrequency = 10;"]
    #[doc = ""]
    #[doc = "xLastWakeTime = xTaskGetTickCount ();"]
    #[doc = "for( ;; )"]
    #[doc = "{"]
    #[doc = "vTaskDelayUntil( &xLastWakeTime, xFrequency );"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup vTaskDelayUntil vTaskDelayUntil"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskDelayUntil(pxPreviousWakeTime: *mut TickType_t, xTimeIncrement: TickType_t);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>BaseType_t xTaskAbortDelay( TaskHandle_t xTask );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " A task will enter the Blocked state when it is waiting for an event.  The"]
    #[doc = " event it is waiting for can be a temporal event (waiting for a time), such"]
    #[doc = " as when vTaskDelay() is called, or an event on an object, such as when"]
    #[doc = " xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task"]
    #[doc = " that is in the Blocked state is used in a call to xTaskAbortDelay() then the"]
    #[doc = " task will leave the Blocked state, and return from whichever function call"]
    #[doc = " placed the task into the Blocked state."]
    #[doc = ""]
    #[doc = " @param xTask The handle of the task to remove from the Blocked state."]
    #[doc = ""]
    #[doc = " @return If the task referenced by xTask was not in the Blocked state then"]
    #[doc = " pdFAIL is returned.  Otherwise pdPASS is returned."]
    #[doc = ""]
    #[doc = " \\defgroup xTaskAbortDelay xTaskAbortDelay"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn xTaskAbortDelay(xTask: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " Obtain the priority of any task."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task to be queried.  Passing a NULL"]
    #[doc = " handle results in the priority of the calling task being returned."]
    #[doc = ""]
    #[doc = " @return The priority of xTask."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vAFunction( void )"]
    #[doc = "{"]
    #[doc = "TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )"]
    #[doc = "{"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup uxTaskPriorityGet uxTaskPriorityGet"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask );</pre>"]
    #[doc = ""]
    #[doc = " A version of uxTaskPriorityGet() that can be used from an ISR."]
    pub fn uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>eTaskState eTaskGetState( TaskHandle_t xTask );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_eTaskGetState must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " Obtain the state of any task.  States are encoded by the eTaskState"]
    #[doc = " enumerated type."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task to be queried."]
    #[doc = ""]
    #[doc = " @return The state of xTask at the time the function was called.  Note the"]
    #[doc = " state of the task might change between the function being called, and the"]
    #[doc = " functions return value being tested by the calling task."]
    pub fn eTaskGetState(xTask: TaskHandle_t) -> eTaskState;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );</pre>"]
    #[doc = ""]
    #[doc = " configUSE_TRACE_FACILITY must be defined as 1 for this function to be"]
    #[doc = " available.  See the configuration section for more information."]
    #[doc = ""]
    #[doc = " Populates a TaskStatus_t structure with information about a task."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task being queried.  If xTask is NULL then"]
    #[doc = " information will be returned about the calling task."]
    #[doc = ""]
    #[doc = " @param pxTaskStatus A pointer to the TaskStatus_t structure that will be"]
    #[doc = " filled with information about the task referenced by the handle passed using"]
    #[doc = " the xTask parameter."]
    #[doc = ""]
    #[doc = " @xGetFreeStackSpace The TaskStatus_t structure contains a member to report"]
    #[doc = " the stack high water mark of the task being queried.  Calculating the stack"]
    #[doc = " high water mark takes a relatively long time, and can make the system"]
    #[doc = " temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to"]
    #[doc = " allow the high water mark checking to be skipped.  The high watermark value"]
    #[doc = " will only be written to the TaskStatus_t structure if xGetFreeStackSpace is"]
    #[doc = " not set to pdFALSE;"]
    #[doc = ""]
    #[doc = " @param eState The TaskStatus_t structure contains a member to report the"]
    #[doc = " state of the task being queried.  Obtaining the task state is not as fast as"]
    #[doc = " a simple assignment - so the eState parameter is provided to allow the state"]
    #[doc = " information to be omitted from the TaskStatus_t structure.  To obtain state"]
    #[doc = " information then set eState to eInvalid - otherwise the value passed in"]
    #[doc = " eState will be reported as the task state in the TaskStatus_t structure."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vAFunction( void )"]
    #[doc = "{"]
    #[doc = "TaskHandle_t xHandle;"]
    #[doc = "TaskStatus_t xTaskDetails;"]
    #[doc = ""]
    #[doc = "xHandle = xTaskGetHandle( \"Task_Name\" );"]
    #[doc = ""]
    #[doc = "configASSERT( xHandle );"]
    #[doc = ""]
    #[doc = "vTaskGetInfo( xHandle,"]
    #[doc = "&xTaskDetails,"]
    #[doc = "pdTRUE, // Include the high water mark in xTaskDetails."]
    #[doc = "eInvalid ); // Include the task state in xTaskDetails."]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup vTaskGetInfo vTaskGetInfo"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskGetInfo(
        xTask: TaskHandle_t,
        pxTaskStatus: *mut TaskStatus_t,
        xGetFreeStackSpace: BaseType_t,
        eState: eTaskState,
    );
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " Set the priority of any task."]
    #[doc = ""]
    #[doc = " A context switch will occur before the function returns if the priority"]
    #[doc = " being set is higher than the currently executing task."]
    #[doc = ""]
    #[doc = " @param xTask Handle to the task for which the priority is being set."]
    #[doc = " Passing a NULL handle results in the priority of the calling task being set."]
    #[doc = ""]
    #[doc = " @param uxNewPriority The priority to which the task will be set."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vAFunction( void )"]
    #[doc = "{"]
    #[doc = "TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup vTaskPrioritySet vTaskPrioritySet"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " Suspend any task.  When suspended a task will never get any microcontroller"]
    #[doc = " processing time, no matter what its priority."]
    #[doc = ""]
    #[doc = " Calls to vTaskSuspend are not accumulative -"]
    #[doc = " i.e. calling vTaskSuspend () twice on the same task still only requires one"]
    #[doc = " call to vTaskResume () to ready the suspended task."]
    #[doc = ""]
    #[doc = " @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL"]
    #[doc = " handle will cause the calling task to be suspended."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vAFunction( void )"]
    #[doc = "{"]
    #[doc = "TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskSuspend( xHandle );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskSuspend( NULL );"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup vTaskSuspend vTaskSuspend"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskResume( TaskHandle_t xTaskToResume );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " Resumes a suspended task."]
    #[doc = ""]
    #[doc = " A task that has been suspended by one or more calls to vTaskSuspend ()"]
    #[doc = " will be made available for running again by a single call to"]
    #[doc = " vTaskResume ()."]
    #[doc = ""]
    #[doc = " @param xTaskToResume Handle to the task being readied."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vAFunction( void )"]
    #[doc = "{"]
    #[doc = "TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskSuspend( xHandle );"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskResume( xHandle );"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup vTaskResume vTaskResume"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskResume(xTaskToResume: TaskHandle_t);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</pre>"]
    #[doc = ""]
    #[doc = " INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be"]
    #[doc = " available.  See the configuration section for more information."]
    #[doc = ""]
    #[doc = " An implementation of vTaskResume() that can be called from within an ISR."]
    #[doc = ""]
    #[doc = " A task that has been suspended by one or more calls to vTaskSuspend ()"]
    #[doc = " will be made available for running again by a single call to"]
    #[doc = " xTaskResumeFromISR ()."]
    #[doc = ""]
    #[doc = " xTaskResumeFromISR() should not be used to synchronise a task with an"]
    #[doc = " interrupt if there is a chance that the interrupt could arrive prior to the"]
    #[doc = " task being suspended - as this can lead to interrupts being missed. Use of a"]
    #[doc = " semaphore as a synchronisation mechanism would avoid this eventuality."]
    #[doc = ""]
    #[doc = " @param xTaskToResume Handle to the task being readied."]
    #[doc = ""]
    #[doc = " @return pdTRUE if resuming the task should result in a context switch,"]
    #[doc = " otherwise pdFALSE. This is used by the ISR to determine if a context switch"]
    #[doc = " may be required following the ISR."]
    #[doc = ""]
    #[doc = " \\defgroup vTaskResumeFromISR vTaskResumeFromISR"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskStartScheduler( void );</pre>"]
    #[doc = ""]
    #[doc = " Starts the real time kernel tick processing.  After calling the kernel"]
    #[doc = " has control over which tasks are executed and when."]
    #[doc = ""]
    #[doc = " See the demo application file main.c for an example of creating"]
    #[doc = " tasks and starting the kernel."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vAFunction( void )"]
    #[doc = "{"]
    #[doc = "xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );"]
    #[doc = ""]
    #[doc = "vTaskStartScheduler ();"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = " \\defgroup vTaskStartScheduler vTaskStartScheduler"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn vTaskStartScheduler();
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskEndScheduler( void );</pre>"]
    #[doc = ""]
    #[doc = " NOTE:  At the time of writing only the x86 real mode port, which runs on a PC"]
    #[doc = " in place of DOS, implements this function."]
    #[doc = ""]
    #[doc = " Stops the real time kernel tick.  All created tasks will be automatically"]
    #[doc = " deleted and multitasking (either preemptive or cooperative) will"]
    #[doc = " stop.  Execution then resumes from the point where vTaskStartScheduler ()"]
    #[doc = " was called, as if vTaskStartScheduler () had just returned."]
    #[doc = ""]
    #[doc = " See the demo application file main. c in the demo/PC directory for an"]
    #[doc = " example that uses vTaskEndScheduler ()."]
    #[doc = ""]
    #[doc = " vTaskEndScheduler () requires an exit function to be defined within the"]
    #[doc = " portable layer (see vPortEndScheduler () in port. c for the PC port).  This"]
    #[doc = " performs hardware specific operations such as stopping the kernel tick."]
    #[doc = ""]
    #[doc = " vTaskEndScheduler () will cause all of the resources allocated by the"]
    #[doc = " kernel to be freed - but will not free resources allocated by application"]
    #[doc = " tasks."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vTaskCode( void * pvParameters )"]
    #[doc = "{"]
    #[doc = "for( ;; )"]
    #[doc = "{"]
    #[doc = ""]
    #[doc = "vTaskEndScheduler ();"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "void vAFunction( void )"]
    #[doc = "{"]
    #[doc = "xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );"]
    #[doc = ""]
    #[doc = "vTaskStartScheduler ();"]
    #[doc = ""]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = ""]
    #[doc = " \\defgroup vTaskEndScheduler vTaskEndScheduler"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn vTaskEndScheduler();
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>void vTaskSuspendAll( void );</pre>"]
    #[doc = ""]
    #[doc = " Suspends the scheduler without disabling interrupts.  Context switches will"]
    #[doc = " not occur while the scheduler is suspended."]
    #[doc = ""]
    #[doc = " After calling vTaskSuspendAll () the calling task will continue to execute"]
    #[doc = " without risk of being swapped out until a call to xTaskResumeAll () has been"]
    #[doc = " made."]
    #[doc = ""]
    #[doc = " API functions that have the potential to cause a context switch (for example,"]
    #[doc = " vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler"]
    #[doc = " is suspended."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vTask1( void * pvParameters )"]
    #[doc = "{"]
    #[doc = "for( ;; )"]
    #[doc = "{"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskSuspendAll ();"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "xTaskResumeAll ();"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup vTaskSuspendAll vTaskSuspendAll"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn vTaskSuspendAll();
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <pre>BaseType_t xTaskResumeAll( void );</pre>"]
    #[doc = ""]
    #[doc = " Resumes scheduler activity after it was suspended by a call to"]
    #[doc = " vTaskSuspendAll()."]
    #[doc = ""]
    #[doc = " xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks"]
    #[doc = " that were previously suspended by a call to vTaskSuspend()."]
    #[doc = ""]
    #[doc = " @return If resuming the scheduler caused a context switch then pdTRUE is"]
    #[doc = "\t\t  returned, otherwise pdFALSE is returned."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vTask1( void * pvParameters )"]
    #[doc = "{"]
    #[doc = "for( ;; )"]
    #[doc = "{"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "vTaskSuspendAll ();"]
    #[doc = ""]
    #[doc = ""]
    #[doc = ""]
    #[doc = "if( !xTaskResumeAll () )"]
    #[doc = "{"]
    #[doc = "taskYIELD ();"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "</pre>"]
    #[doc = " \\defgroup xTaskResumeAll xTaskResumeAll"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn xTaskResumeAll() -> BaseType_t;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>TickType_t xTaskGetTickCount( void );</PRE>"]
    #[doc = ""]
    #[doc = " @return The count of ticks since vTaskStartScheduler was called."]
    #[doc = ""]
    #[doc = " \\defgroup xTaskGetTickCount xTaskGetTickCount"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn xTaskGetTickCount() -> TickType_t;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>TickType_t xTaskGetTickCountFromISR( void );</PRE>"]
    #[doc = ""]
    #[doc = " @return The count of ticks since vTaskStartScheduler was called."]
    #[doc = ""]
    #[doc = " This is a version of xTaskGetTickCount() that is safe to be called from an"]
    #[doc = " ISR - provided that TickType_t is the natural word size of the"]
    #[doc = " microcontroller being used or interrupt nesting is either not supported or"]
    #[doc = " not being used."]
    #[doc = ""]
    #[doc = " \\defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn xTaskGetTickCountFromISR() -> TickType_t;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>uint16_t uxTaskGetNumberOfTasks( void );</PRE>"]
    #[doc = ""]
    #[doc = " @return The number of tasks that the real time kernel is currently managing."]
    #[doc = " This includes all ready, blocked and suspended tasks.  A task that"]
    #[doc = " has been deleted but not yet freed by the idle task will also be"]
    #[doc = " included in the count."]
    #[doc = ""]
    #[doc = " \\defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn uxTaskGetNumberOfTasks() -> UBaseType_t;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>char *pcTaskGetName( TaskHandle_t xTaskToQuery );</PRE>"]
    #[doc = ""]
    #[doc = " @return The text (human readable) name of the task referenced by the handle"]
    #[doc = " xTaskToQuery.  A task can query its own name by either passing in its own"]
    #[doc = " handle, or by setting xTaskToQuery to NULL."]
    #[doc = ""]
    #[doc = " \\defgroup pcTaskGetName pcTaskGetName"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn pcTaskGetName(xTaskToQuery: TaskHandle_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );</PRE>"]
    #[doc = ""]
    #[doc = " NOTE:  This function takes a relatively long time to complete and should be"]
    #[doc = " used sparingly."]
    #[doc = ""]
    #[doc = " @return The handle of the task that has the human readable name pcNameToQuery."]
    #[doc = " NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle"]
    #[doc = " must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available."]
    #[doc = ""]
    #[doc = " \\defgroup pcTaskGetHandle pcTaskGetHandle"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn xTaskGetHandle(pcNameToQuery: *const ::std::os::raw::c_char) -> TaskHandle_t;
}
extern "C" {
    #[doc = " task.h"]
    #[doc = " <PRE>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</PRE>"]
    #[doc = ""]
    #[doc = " INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for"]
    #[doc = " this function to be available."]
    #[doc = ""]
    #[doc = " Returns the high water mark of the stack associated with xTask.  That is,"]
    #[doc = " the minimum free stack space there has been (in words, so on a 32 bit machine"]
    #[doc = " a value of 1 means 4 bytes) since the task started.  The smaller the returned"]
    #[doc = " number the closer the task has come to overflowing its stack."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task associated with the stack to be checked."]
    #[doc = " Set xTask to NULL to check the stack of the calling task."]
    #[doc = ""]
    #[doc = " @return The smallest amount of free stack space there has been (in words, so"]
    #[doc = " actual spaces on the stack rather than bytes) since the task referenced by"]
    #[doc = " xTask was created."]
    pub fn uxTaskGetStackHighWaterMark(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn vTaskSetThreadLocalStoragePointer(
        xTaskToSet: TaskHandle_t,
        xIndex: BaseType_t,
        pvValue: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn pvTaskGetThreadLocalStoragePointer(
        xTaskToQuery: TaskHandle_t,
        xIndex: BaseType_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn pvTaskGetThreadLocalStorageBufferPointer(
        xTaskToQuery: TaskHandle_t,
        xIndex: BaseType_t,
    ) -> *mut *mut ::core::ffi::c_void;
}
#[doc = " Prototype of local storage pointer deletion callback."]
pub type TlsDeleteCallbackFunction_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *mut ::core::ffi::c_void),
>;
extern "C" {
    #[doc = " Set local storage pointer and deletion callback."]
    #[doc = ""]
    #[doc = " Each task contains an array of pointers that is dimensioned by the"]
    #[doc = " configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h."]
    #[doc = " The kernel does not use the pointers itself, so the application writer"]
    #[doc = " can use the pointers for any purpose they wish."]
    #[doc = ""]
    #[doc = " Local storage pointers set for a task can reference dynamically"]
    #[doc = " allocated resources. This function is similar to"]
    #[doc = " vTaskSetThreadLocalStoragePointer, but provides a way to release"]
    #[doc = " these resources when the task gets deleted. For each pointer,"]
    #[doc = " a callback function can be set. This function will be called"]
    #[doc = " when task is deleted, with the local storage pointer index"]
    #[doc = " and value as arguments."]
    #[doc = ""]
    #[doc = " @param xTaskToSet  Task to set thread local storage pointer for"]
    #[doc = " @param xIndex The index of the pointer to set, from 0 to"]
    #[doc = "               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1."]
    #[doc = " @param pvValue  Pointer value to set."]
    #[doc = " @param pvDelCallback  Function to call to dispose of the local"]
    #[doc = "                       storage pointer when the task is deleted."]
    pub fn vTaskSetThreadLocalStoragePointerAndDelCallback(
        xTaskToSet: TaskHandle_t,
        xIndex: BaseType_t,
        pvValue: *mut ::core::ffi::c_void,
        pvDelCallback: TlsDeleteCallbackFunction_t,
    );
}
extern "C" {
    #[doc = " task.h"]
    #[doc = " <pre>BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</pre>"]
    #[doc = ""]
    #[doc = " Calls the hook function associated with xTask.  Passing xTask as NULL has"]
    #[doc = " the effect of calling the Running tasks (the calling task) hook function."]
    #[doc = ""]
    #[doc = " pvParameter is passed to the hook function for the task to interpret as it"]
    #[doc = " wants.  The return value is the value returned by the task hook function"]
    #[doc = " registered by the user."]
    pub fn xTaskCallApplicationTaskHook(
        xTask: TaskHandle_t,
        pvParameter: *mut ::core::ffi::c_void,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " xTaskGetIdleTaskHandle() is only available if"]
    #[doc = " INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h."]
    #[doc = ""]
    #[doc = " Simply returns the handle of the idle task.  It is not valid to call"]
    #[doc = " xTaskGetIdleTaskHandle() before the scheduler has been started."]
    pub fn xTaskGetIdleTaskHandle() -> TaskHandle_t;
}
extern "C" {
    #[doc = " configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for"]
    #[doc = " uxTaskGetSystemState() to be available."]
    #[doc = ""]
    #[doc = " uxTaskGetSystemState() populates an TaskStatus_t structure for each task in"]
    #[doc = " the system.  TaskStatus_t structures contain, among other things, members"]
    #[doc = " for the task handle, task name, task priority, task state, and total amount"]
    #[doc = " of run time consumed by the task.  See the TaskStatus_t structure"]
    #[doc = " definition in this file for the full member list."]
    #[doc = ""]
    #[doc = " NOTE:  This function is intended for debugging use only as its use results in"]
    #[doc = " the scheduler remaining suspended for an extended period."]
    #[doc = ""]
    #[doc = " @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures."]
    #[doc = " The array must contain at least one TaskStatus_t structure for each task"]
    #[doc = " that is under the control of the RTOS.  The number of tasks under the control"]
    #[doc = " of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function."]
    #[doc = ""]
    #[doc = " @param uxArraySize The size of the array pointed to by the pxTaskStatusArray"]
    #[doc = " parameter.  The size is specified as the number of indexes in the array, or"]
    #[doc = " the number of TaskStatus_t structures contained in the array, not by the"]
    #[doc = " number of bytes in the array."]
    #[doc = ""]
    #[doc = " @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in"]
    #[doc = " FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the"]
    #[doc = " total run time (as defined by the run time stats clock, see"]
    #[doc = " http://www.freertos.org/rtos-run-time-stats.html) since the target booted."]
    #[doc = " pulTotalRunTime can be set to NULL to omit the total run time information."]
    #[doc = ""]
    #[doc = " @return The number of TaskStatus_t structures that were populated by"]
    #[doc = " uxTaskGetSystemState().  This should equal the number returned by the"]
    #[doc = " uxTaskGetNumberOfTasks() API function, but will be zero if the value passed"]
    #[doc = " in the uxArraySize parameter was too small."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = "<pre>"]
    #[doc = "void vTaskGetRunTimeStats( char *pcWriteBuffer )"]
    #[doc = "{"]
    #[doc = "TaskStatus_t *pxTaskStatusArray;"]
    #[doc = "volatile UBaseType_t uxArraySize, x;"]
    #[doc = "uint32_t ulTotalRunTime, ulStatsAsPercentage;"]
    #[doc = ""]
    #[doc = "pcWriteBuffer = 0x00;"]
    #[doc = ""]
    #[doc = "uxArraySize = uxTaskGetNumberOfTasks();"]
    #[doc = ""]
    #[doc = "pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );"]
    #[doc = ""]
    #[doc = "if( pxTaskStatusArray != NULL )"]
    #[doc = "{"]
    #[doc = "uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );"]
    #[doc = ""]
    #[doc = "ulTotalRunTime /= 100UL;"]
    #[doc = ""]
    #[doc = "if( ulTotalRunTime > 0 )"]
    #[doc = "{"]
    #[doc = "for( x = 0; x < uxArraySize; x++ )"]
    #[doc = "{"]
    #[doc = "ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;"]
    #[doc = ""]
    #[doc = "if( ulStatsAsPercentage > 0UL )"]
    #[doc = "{"]
    #[doc = "sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t%lu%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );"]
    #[doc = "}"]
    #[doc = "else"]
    #[doc = "{"]
    #[doc = "sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t<1%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = ""]
    #[doc = "vPortFree( pxTaskStatusArray );"]
    #[doc = "}"]
    #[doc = "}"]
    #[doc = "</pre>"]
    pub fn uxTaskGetSystemState(
        pxTaskStatusArray: *mut TaskStatus_t,
        uxArraySize: UBaseType_t,
        pulTotalRunTime: *mut u32,
    ) -> UBaseType_t;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>void vTaskList( char *pcWriteBuffer );</PRE>"]
    #[doc = ""]
    #[doc = " configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must"]
    #[doc = " both be defined as 1 for this function to be available.  See the"]
    #[doc = " configuration section of the FreeRTOS.org website for more information."]
    #[doc = ""]
    #[doc = " NOTE 1: This function will disable interrupts for its duration.  It is"]
    #[doc = " not intended for normal application runtime use but as a debug aid."]
    #[doc = ""]
    #[doc = " Lists all the current tasks, along with their current state and stack"]
    #[doc = " usage high water mark."]
    #[doc = ""]
    #[doc = " Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or"]
    #[doc = " suspended ('S')."]
    #[doc = ""]
    #[doc = " PLEASE NOTE:"]
    #[doc = ""]
    #[doc = " This function is provided for convenience only, and is used by many of the"]
    #[doc = " demo applications.  Do not consider it to be part of the scheduler."]
    #[doc = ""]
    #[doc = " vTaskList() calls uxTaskGetSystemState(), then formats part of the"]
    #[doc = " uxTaskGetSystemState() output into a human readable table that displays task"]
    #[doc = " names, states and stack usage."]
    #[doc = ""]
    #[doc = " vTaskList() has a dependency on the sprintf() C library function that might"]
    #[doc = " bloat the code size, use a lot of stack, and provide different results on"]
    #[doc = " different platforms.  An alternative, tiny, third party, and limited"]
    #[doc = " functionality implementation of sprintf() is provided in many of the"]
    #[doc = " FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note"]
    #[doc = " printf-stdarg.c does not provide a full snprintf() implementation!)."]
    #[doc = ""]
    #[doc = " It is recommended that production systems call uxTaskGetSystemState()"]
    #[doc = " directly to get access to raw stats data, rather than indirectly through a"]
    #[doc = " call to vTaskList()."]
    #[doc = ""]
    #[doc = " @param pcWriteBuffer A buffer into which the above mentioned details"]
    #[doc = " will be written, in ASCII form.  This buffer is assumed to be large"]
    #[doc = " enough to contain the generated report.  Approximately 40 bytes per"]
    #[doc = " task should be sufficient."]
    #[doc = ""]
    #[doc = " \\defgroup vTaskList vTaskList"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn vTaskList(pcWriteBuffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>"]
    #[doc = ""]
    #[doc = " configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS"]
    #[doc = " must both be defined as 1 for this function to be available.  The application"]
    #[doc = " must also then provide definitions for"]
    #[doc = " portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()"]
    #[doc = " to configure a peripheral timer/counter and return the timers current count"]
    #[doc = " value respectively.  The counter should be at least 10 times the frequency of"]
    #[doc = " the tick count."]
    #[doc = ""]
    #[doc = " NOTE 1: This function will disable interrupts for its duration.  It is"]
    #[doc = " not intended for normal application runtime use but as a debug aid."]
    #[doc = ""]
    #[doc = " Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total"]
    #[doc = " accumulated execution time being stored for each task.  The resolution"]
    #[doc = " of the accumulated time value depends on the frequency of the timer"]
    #[doc = " configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro."]
    #[doc = " Calling vTaskGetRunTimeStats() writes the total execution time of each"]
    #[doc = " task into a buffer, both as an absolute count value and as a percentage"]
    #[doc = " of the total system execution time."]
    #[doc = ""]
    #[doc = " NOTE 2:"]
    #[doc = ""]
    #[doc = " This function is provided for convenience only, and is used by many of the"]
    #[doc = " demo applications.  Do not consider it to be part of the scheduler."]
    #[doc = ""]
    #[doc = " vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the"]
    #[doc = " uxTaskGetSystemState() output into a human readable table that displays the"]
    #[doc = " amount of time each task has spent in the Running state in both absolute and"]
    #[doc = " percentage terms."]
    #[doc = ""]
    #[doc = " vTaskGetRunTimeStats() has a dependency on the sprintf() C library function"]
    #[doc = " that might bloat the code size, use a lot of stack, and provide different"]
    #[doc = " results on different platforms.  An alternative, tiny, third party, and"]
    #[doc = " limited functionality implementation of sprintf() is provided in many of the"]
    #[doc = " FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note"]
    #[doc = " printf-stdarg.c does not provide a full snprintf() implementation!)."]
    #[doc = ""]
    #[doc = " It is recommended that production systems call uxTaskGetSystemState() directly"]
    #[doc = " to get access to raw stats data, rather than indirectly through a call to"]
    #[doc = " vTaskGetRunTimeStats()."]
    #[doc = ""]
    #[doc = " @param pcWriteBuffer A buffer into which the execution times will be"]
    #[doc = " written, in ASCII form.  This buffer is assumed to be large enough to"]
    #[doc = " contain the generated report.  Approximately 40 bytes per task should"]
    #[doc = " be sufficient."]
    #[doc = ""]
    #[doc = " \\defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats"]
    #[doc = " \\ingroup TaskUtils"]
    pub fn vTaskGetRunTimeStats(pcWriteBuffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</PRE>"]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " A notification sent to a task will remain pending until it is cleared by the"]
    #[doc = " task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was"]
    #[doc = " already in the Blocked state to wait for a notification when the notification"]
    #[doc = " arrives then the task will automatically be removed from the Blocked state"]
    #[doc = " (unblocked) and the notification cleared."]
    #[doc = ""]
    #[doc = " A task can use xTaskNotifyWait() to [optionally] block to wait for a"]
    #[doc = " notification to be pending, or ulTaskNotifyTake() to [optionally] block"]
    #[doc = " to wait for its notification value to have a non-zero value.  The task does"]
    #[doc = " not consume any CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
    #[doc = " task can be returned from the xTaskCreate() API function used to create the"]
    #[doc = " task, and the handle of the currently running task can be obtained by calling"]
    #[doc = " xTaskGetCurrentTaskHandle()."]
    #[doc = ""]
    #[doc = " @param ulValue Data that can be sent with the notification.  How the data is"]
    #[doc = " used depends on the value of the eAction parameter."]
    #[doc = ""]
    #[doc = " @param eAction Specifies how the notification updates the task's notification"]
    #[doc = " value, if at all.  Valid values for eAction are as follows:"]
    #[doc = ""]
    #[doc = " eSetBits -"]
    #[doc = " The task's notification value is bitwise ORed with ulValue.  xTaskNofify()"]
    #[doc = " always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = " eIncrement -"]
    #[doc = " The task's notification value is incremented.  ulValue is not used and"]
    #[doc = " xTaskNotify() always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = " eSetValueWithOverwrite -"]
    #[doc = " The task's notification value is set to the value of ulValue, even if the"]
    #[doc = " task being notified had not yet processed the previous notification (the"]
    #[doc = " task already had a notification pending).  xTaskNotify() always returns"]
    #[doc = " pdPASS in this case."]
    #[doc = ""]
    #[doc = " eSetValueWithoutOverwrite -"]
    #[doc = " If the task being notified did not already have a notification pending then"]
    #[doc = " the task's notification value is set to ulValue and xTaskNotify() will"]
    #[doc = " return pdPASS.  If the task being notified already had a notification"]
    #[doc = " pending then no action is performed and pdFAIL is returned."]
    #[doc = ""]
    #[doc = " eNoAction -"]
    #[doc = " The task receives a notification without its notification value being"]
    #[doc = " updated.  ulValue is not used and xTaskNotify() always returns pdPASS in"]
    #[doc = " this case."]
    #[doc = ""]
    #[doc = "  pulPreviousNotificationValue -"]
    #[doc = "  Can be used to pass out the subject task's notification value before any"]
    #[doc = "  bits are modified by the notify function."]
    #[doc = ""]
    #[doc = " @return Dependent on the value of eAction.  See the description of the"]
    #[doc = " eAction parameter."]
    #[doc = ""]
    #[doc = " \\defgroup xTaskNotify xTaskNotify"]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn xTaskGenericNotify(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</PRE>"]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " A version of xTaskNotify() that can be used from an interrupt service routine"]
    #[doc = " (ISR)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " A notification sent to a task will remain pending until it is cleared by the"]
    #[doc = " task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was"]
    #[doc = " already in the Blocked state to wait for a notification when the notification"]
    #[doc = " arrives then the task will automatically be removed from the Blocked state"]
    #[doc = " (unblocked) and the notification cleared."]
    #[doc = ""]
    #[doc = " A task can use xTaskNotifyWait() to [optionally] block to wait for a"]
    #[doc = " notification to be pending, or ulTaskNotifyTake() to [optionally] block"]
    #[doc = " to wait for its notification value to have a non-zero value.  The task does"]
    #[doc = " not consume any CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
    #[doc = " task can be returned from the xTaskCreate() API function used to create the"]
    #[doc = " task, and the handle of the currently running task can be obtained by calling"]
    #[doc = " xTaskGetCurrentTaskHandle()."]
    #[doc = ""]
    #[doc = " @param ulValue Data that can be sent with the notification.  How the data is"]
    #[doc = " used depends on the value of the eAction parameter."]
    #[doc = ""]
    #[doc = " @param eAction Specifies how the notification updates the task's notification"]
    #[doc = " value, if at all.  Valid values for eAction are as follows:"]
    #[doc = ""]
    #[doc = " eSetBits -"]
    #[doc = " The task's notification value is bitwise ORed with ulValue.  xTaskNofify()"]
    #[doc = " always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = " eIncrement -"]
    #[doc = " The task's notification value is incremented.  ulValue is not used and"]
    #[doc = " xTaskNotify() always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = " eSetValueWithOverwrite -"]
    #[doc = " The task's notification value is set to the value of ulValue, even if the"]
    #[doc = " task being notified had not yet processed the previous notification (the"]
    #[doc = " task already had a notification pending).  xTaskNotify() always returns"]
    #[doc = " pdPASS in this case."]
    #[doc = ""]
    #[doc = " eSetValueWithoutOverwrite -"]
    #[doc = " If the task being notified did not already have a notification pending then"]
    #[doc = " the task's notification value is set to ulValue and xTaskNotify() will"]
    #[doc = " return pdPASS.  If the task being notified already had a notification"]
    #[doc = " pending then no action is performed and pdFAIL is returned."]
    #[doc = ""]
    #[doc = " eNoAction -"]
    #[doc = " The task receives a notification without its notification value being"]
    #[doc = " updated.  ulValue is not used and xTaskNotify() always returns pdPASS in"]
    #[doc = " this case."]
    #[doc = ""]
    #[doc = " @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set"]
    #[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the"]
    #[doc = " task to which the notification was sent to leave the Blocked state, and the"]
    #[doc = " unblocked task has a priority higher than the currently running task.  If"]
    #[doc = " xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should"]
    #[doc = " be requested before the interrupt is exited.  How a context switch is"]
    #[doc = " requested from an ISR is dependent on the port - see the documentation page"]
    #[doc = " for the port in use."]
    #[doc = ""]
    #[doc = " @return Dependent on the value of eAction.  See the description of the"]
    #[doc = " eAction parameter."]
    #[doc = ""]
    #[doc = " \\defgroup xTaskNotify xTaskNotify"]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn xTaskGenericNotifyFromISR(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</pre>"]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " A notification sent to a task will remain pending until it is cleared by the"]
    #[doc = " task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was"]
    #[doc = " already in the Blocked state to wait for a notification when the notification"]
    #[doc = " arrives then the task will automatically be removed from the Blocked state"]
    #[doc = " (unblocked) and the notification cleared."]
    #[doc = ""]
    #[doc = " A task can use xTaskNotifyWait() to [optionally] block to wait for a"]
    #[doc = " notification to be pending, or ulTaskNotifyTake() to [optionally] block"]
    #[doc = " to wait for its notification value to have a non-zero value.  The task does"]
    #[doc = " not consume any CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value"]
    #[doc = " will be cleared in the calling task's notification value before the task"]
    #[doc = " checks to see if any notifications are pending, and optionally blocks if no"]
    #[doc = " notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if"]
    #[doc = " limits.h is included) or 0xffffffffUL (if limits.h is not included) will have"]
    #[doc = " the effect of resetting the task's notification value to 0.  Setting"]
    #[doc = " ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged."]
    #[doc = ""]
    #[doc = " @param ulBitsToClearOnExit If a notification is pending or received before"]
    #[doc = " the calling task exits the xTaskNotifyWait() function then the task's"]
    #[doc = " notification value (see the xTaskNotify() API function) is passed out using"]
    #[doc = " the pulNotificationValue parameter.  Then any bits that are set in"]
    #[doc = " ulBitsToClearOnExit will be cleared in the task's notification value (note"]
    #[doc = " *pulNotificationValue is set before any bits are cleared).  Setting"]
    #[doc = " ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL"]
    #[doc = " (if limits.h is not included) will have the effect of resetting the task's"]
    #[doc = " notification value to 0 before the function exits.  Setting"]
    #[doc = " ulBitsToClearOnExit to 0 will leave the task's notification value unchanged"]
    #[doc = " when the function exits (in which case the value passed out in"]
    #[doc = " pulNotificationValue will match the task's notification value)."]
    #[doc = ""]
    #[doc = " @param pulNotificationValue Used to pass the task's notification value out"]
    #[doc = " of the function.  Note the value passed out will not be effected by the"]
    #[doc = " clearing of any bits caused by ulBitsToClearOnExit being non-zero."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time that the task should wait in"]
    #[doc = " the Blocked state for a notification to be received, should a notification"]
    #[doc = " not already be pending when xTaskNotifyWait() was called.  The task"]
    #[doc = " will not consume any processing time while it is in the Blocked state.  This"]
    #[doc = " is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be"]
    #[doc = " used to convert a time specified in milliseconds to a time specified in"]
    #[doc = " ticks."]
    #[doc = ""]
    #[doc = " @return If a notification was received (including notifications that were"]
    #[doc = " already pending when xTaskNotifyWait was called) then pdPASS is"]
    #[doc = " returned.  Otherwise pdFAIL is returned."]
    #[doc = ""]
    #[doc = " \\defgroup xTaskNotifyWait xTaskNotifyWait"]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn xTaskNotifyWait(
        ulBitsToClearOnEntry: u32,
        ulBitsToClearOnExit: u32,
        pulNotificationValue: *mut u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );"]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro"]
    #[doc = " to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " A version of xTaskNotifyGive() that can be called from an interrupt service"]
    #[doc = " routine (ISR)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " vTaskNotifyGiveFromISR() is intended for use when task notifications are"]
    #[doc = " used as light weight and faster binary or counting semaphore equivalents."]
    #[doc = " Actual FreeRTOS semaphores are given from an ISR using the"]
    #[doc = " xSemaphoreGiveFromISR() API function, the equivalent action that instead uses"]
    #[doc = " a task notification is vTaskNotifyGiveFromISR()."]
    #[doc = ""]
    #[doc = " When task notifications are being used as a binary or counting semaphore"]
    #[doc = " equivalent then the task being notified should wait for the notification"]
    #[doc = " using the ulTaskNotificationTake() API function rather than the"]
    #[doc = " xTaskNotifyWait() API function."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details."]
    #[doc = ""]
    #[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
    #[doc = " task can be returned from the xTaskCreate() API function used to create the"]
    #[doc = " task, and the handle of the currently running task can be obtained by calling"]
    #[doc = " xTaskGetCurrentTaskHandle()."]
    #[doc = ""]
    #[doc = " @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set"]
    #[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the"]
    #[doc = " task to which the notification was sent to leave the Blocked state, and the"]
    #[doc = " unblocked task has a priority higher than the currently running task.  If"]
    #[doc = " vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch"]
    #[doc = " should be requested before the interrupt is exited.  How a context switch is"]
    #[doc = " requested from an ISR is dependent on the port - see the documentation page"]
    #[doc = " for the port in use."]
    #[doc = ""]
    #[doc = " \\defgroup xTaskNotifyWait xTaskNotifyWait"]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn vTaskNotifyGiveFromISR(
        xTaskToNotify: TaskHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</pre>"]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " ulTaskNotifyTake() is intended for use when a task notification is used as a"]
    #[doc = " faster and lighter weight binary or counting semaphore alternative.  Actual"]
    #[doc = " FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the"]
    #[doc = " equivalent action that instead uses a task notification is"]
    #[doc = " ulTaskNotifyTake()."]
    #[doc = ""]
    #[doc = " When a task is using its notification value as a binary or counting semaphore"]
    #[doc = " other tasks should send notifications to it using the xTaskNotifyGive()"]
    #[doc = " macro, or xTaskNotify() function with the eAction parameter set to"]
    #[doc = " eIncrement."]
    #[doc = ""]
    #[doc = " ulTaskNotifyTake() can either clear the task's notification value to"]
    #[doc = " zero on exit, in which case the notification value acts like a binary"]
    #[doc = " semaphore, or decrement the task's notification value on exit, in which case"]
    #[doc = " the notification value acts like a counting semaphore."]
    #[doc = ""]
    #[doc = " A task can use ulTaskNotifyTake() to [optionally] block to wait for a"]
    #[doc = " the task's notification value to be non-zero.  The task does not consume any"]
    #[doc = " CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " Where as xTaskNotifyWait() will return when a notification is pending,"]
    #[doc = " ulTaskNotifyTake() will return when the task's notification value is"]
    #[doc = " not zero."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's"]
    #[doc = " notification value is decremented when the function exits.  In this way the"]
    #[doc = " notification value acts like a counting semaphore.  If xClearCountOnExit is"]
    #[doc = " not pdFALSE then the task's notification value is cleared to zero when the"]
    #[doc = " function exits.  In this way the notification value acts like a binary"]
    #[doc = " semaphore."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time that the task should wait in"]
    #[doc = " the Blocked state for the task's notification value to be greater than zero,"]
    #[doc = " should the count not already be greater than zero when"]
    #[doc = " ulTaskNotifyTake() was called.  The task will not consume any processing"]
    #[doc = " time while it is in the Blocked state.  This is specified in kernel ticks,"]
    #[doc = " the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time"]
    #[doc = " specified in milliseconds to a time specified in ticks."]
    #[doc = ""]
    #[doc = " @return The task's notification count before it is either cleared to zero or"]
    #[doc = " decremented (see the xClearCountOnExit parameter)."]
    #[doc = ""]
    #[doc = " \\defgroup ulTaskNotifyTake ulTaskNotifyTake"]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn ulTaskNotifyTake(xClearCountOnExit: BaseType_t, xTicksToWait: TickType_t) -> u32;
}
extern "C" {
    #[doc = " task. h"]
    #[doc = " <PRE>BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );</pre>"]
    #[doc = ""]
    #[doc = " If the notification state of the task referenced by the handle xTask is"]
    #[doc = " eNotified, then set the task's notification state to eNotWaitingNotification."]
    #[doc = " The task's notification value is not altered.  Set xTask to NULL to clear the"]
    #[doc = " notification state of the calling task."]
    #[doc = ""]
    #[doc = " @return pdTRUE if the task's notification state was set to"]
    #[doc = " eNotWaitingNotification, otherwise pdFALSE."]
    #[doc = " \\defgroup xTaskNotifyStateClear xTaskNotifyStateClear"]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn xTaskNotifyStateClear(xTask: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xTaskIncrementTick() -> BaseType_t;
}
extern "C" {
    pub fn vTaskPlaceOnEventList(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn vTaskPlaceOnUnorderedEventList(
        pxEventList: *mut List_t,
        xItemValue: TickType_t,
        xTicksToWait: TickType_t,
    );
}
extern "C" {
    pub fn vTaskPlaceOnEventListRestricted(
        pxEventList: *mut List_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
extern "C" {
    pub fn xTaskRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskRemoveFromUnorderedEventList(
        pxEventListItem: *mut ListItem_t,
        xItemValue: TickType_t,
    );
}
extern "C" {
    pub fn vTaskSwitchContext();
}
extern "C" {
    pub fn uxTaskResetEventItemValue() -> TickType_t;
}
extern "C" {
    pub fn xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
extern "C" {
    pub fn xTaskCheckForTimeOut(
        pxTimeOut: *mut TimeOut_t,
        pxTicksToWait: *mut TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskMissedYield();
}
extern "C" {
    pub fn xTaskGetSchedulerState() -> BaseType_t;
}
extern "C" {
    pub fn xTaskPriorityInherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xTaskPriorityDisinherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskPriorityDisinheritAfterTimeout(
        pxMutexHolder: TaskHandle_t,
        uxHighestPriorityWaitingTask: UBaseType_t,
    );
}
extern "C" {
    pub fn uxTaskGetTaskNumber(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn vTaskSetTaskNumber(xTask: TaskHandle_t, uxHandle: UBaseType_t);
}
extern "C" {
    pub fn vTaskStepTick(xTicksToJump: TickType_t);
}
extern "C" {
    pub fn eTaskConfirmSleepModeStatus() -> eSleepModeStatus;
}
extern "C" {
    pub fn pvTaskIncrementMutexHeldCount() -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn vTaskInternalSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
#[doc = " Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system."]
#[doc = " We need this struct because TCB_t is defined (hidden) in tasks.c."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_SNAPSHOT {
    #[doc = "< Address of task control block."]
    pub pxTCB: *mut ::core::ffi::c_void,
    #[doc = "< Points to the location of the last item placed on the tasks stack."]
    pub pxTopOfStack: *mut StackType_t,
    #[doc = "< Points to the end of the stack. pxTopOfStack < pxEndOfStack, stack grows hi2lo"]
    #[doc = "pxTopOfStack > pxEndOfStack, stack grows lo2hi"]
    pub pxEndOfStack: *mut StackType_t,
}
#[doc = " Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system."]
#[doc = " We need this struct because TCB_t is defined (hidden) in tasks.c."]
pub type TaskSnapshot_t = xTASK_SNAPSHOT;
extern "C" {
    pub fn uxTaskGetSnapshotAll(
        pxTaskSnapshotArray: *mut TaskSnapshot_t,
        uxArraySize: UBaseType_t,
        pxTcbSz: *mut UBaseType_t,
    ) -> UBaseType_t;
}
extern "C" {
    #[doc = " @brief Modify task stack size dynamically."]
    #[doc = ""]
    #[doc = " @param xTask task handle which created by xTaskCreate."]
    #[doc = " @param newStackDepth task' new stack size."]
    #[doc = ""]
    #[doc = " @return pdPASS if success or others if failed"]
    pub fn vTaskModifyStackDepth(xTask: TaskHandle_t, newStackDepth: u16) -> BaseType_t;
}
#[doc = "< GPIO0, input and output"]
pub const gpio_num_t_GPIO_NUM_0: gpio_num_t = 0;
#[doc = "< GPIO1, input and output"]
pub const gpio_num_t_GPIO_NUM_1: gpio_num_t = 1;
#[doc = "< GPIO2, input and output"]
pub const gpio_num_t_GPIO_NUM_2: gpio_num_t = 2;
#[doc = "< GPIO3, input and output"]
pub const gpio_num_t_GPIO_NUM_3: gpio_num_t = 3;
#[doc = "< GPIO4, input and output"]
pub const gpio_num_t_GPIO_NUM_4: gpio_num_t = 4;
#[doc = "< GPIO5, input and output"]
pub const gpio_num_t_GPIO_NUM_5: gpio_num_t = 5;
#[doc = "< GPIO6, input and output"]
pub const gpio_num_t_GPIO_NUM_6: gpio_num_t = 6;
#[doc = "< GPIO7, input and output"]
pub const gpio_num_t_GPIO_NUM_7: gpio_num_t = 7;
#[doc = "< GPIO8, input and output"]
pub const gpio_num_t_GPIO_NUM_8: gpio_num_t = 8;
#[doc = "< GPIO9, input and output"]
pub const gpio_num_t_GPIO_NUM_9: gpio_num_t = 9;
#[doc = "< GPIO10, input and output"]
pub const gpio_num_t_GPIO_NUM_10: gpio_num_t = 10;
#[doc = "< GPIO11, input and output"]
pub const gpio_num_t_GPIO_NUM_11: gpio_num_t = 11;
#[doc = "< GPIO12, input and output"]
pub const gpio_num_t_GPIO_NUM_12: gpio_num_t = 12;
#[doc = "< GPIO13, input and output"]
pub const gpio_num_t_GPIO_NUM_13: gpio_num_t = 13;
#[doc = "< GPIO14, input and output"]
pub const gpio_num_t_GPIO_NUM_14: gpio_num_t = 14;
#[doc = "< GPIO15, input and output"]
pub const gpio_num_t_GPIO_NUM_15: gpio_num_t = 15;
#[doc = "< GPIO16, input and output"]
pub const gpio_num_t_GPIO_NUM_16: gpio_num_t = 16;
pub const gpio_num_t_GPIO_NUM_MAX: gpio_num_t = 17;
pub type gpio_num_t = ::std::os::raw::c_uint;
#[doc = "< Disable GPIO interrupt"]
pub const gpio_int_type_t_GPIO_INTR_DISABLE: gpio_int_type_t = 0;
#[doc = "< GPIO interrupt type : rising edge"]
pub const gpio_int_type_t_GPIO_INTR_POSEDGE: gpio_int_type_t = 1;
#[doc = "< GPIO interrupt type : falling edge"]
pub const gpio_int_type_t_GPIO_INTR_NEGEDGE: gpio_int_type_t = 2;
#[doc = "< GPIO interrupt type : both rising and falling edge"]
pub const gpio_int_type_t_GPIO_INTR_ANYEDGE: gpio_int_type_t = 3;
#[doc = "< GPIO interrupt type : input low level trigger"]
pub const gpio_int_type_t_GPIO_INTR_LOW_LEVEL: gpio_int_type_t = 4;
#[doc = "< GPIO interrupt type : input high level trigger"]
pub const gpio_int_type_t_GPIO_INTR_HIGH_LEVEL: gpio_int_type_t = 5;
pub const gpio_int_type_t_GPIO_INTR_MAX: gpio_int_type_t = 6;
pub type gpio_int_type_t = ::std::os::raw::c_uint;
#[doc = "< GPIO mode : disable input and output"]
pub const gpio_mode_t_GPIO_MODE_DISABLE: gpio_mode_t = 0;
#[doc = "< GPIO mode : input only"]
pub const gpio_mode_t_GPIO_MODE_INPUT: gpio_mode_t = 1;
#[doc = "< GPIO mode : output only mode"]
pub const gpio_mode_t_GPIO_MODE_OUTPUT: gpio_mode_t = 2;
#[doc = "< GPIO mode : output only with open-drain mode"]
pub const gpio_mode_t_GPIO_MODE_OUTPUT_OD: gpio_mode_t = 6;
pub type gpio_mode_t = ::std::os::raw::c_uint;
#[doc = "< Pad pull up"]
pub const gpio_pull_mode_t_GPIO_PULLUP_ONLY: gpio_pull_mode_t = 0;
#[doc = "< Pad pull down"]
pub const gpio_pull_mode_t_GPIO_PULLDOWN_ONLY: gpio_pull_mode_t = 1;
#[doc = "< Pad floating"]
pub const gpio_pull_mode_t_GPIO_FLOATING: gpio_pull_mode_t = 2;
pub type gpio_pull_mode_t = ::std::os::raw::c_uint;
#[doc = "< Disable GPIO pull-up resistor"]
pub const gpio_pullup_t_GPIO_PULLUP_DISABLE: gpio_pullup_t = 0;
#[doc = "< Enable GPIO pull-up resistor"]
pub const gpio_pullup_t_GPIO_PULLUP_ENABLE: gpio_pullup_t = 1;
pub type gpio_pullup_t = ::std::os::raw::c_uint;
#[doc = "< Disable GPIO pull-down resistor"]
pub const gpio_pulldown_t_GPIO_PULLDOWN_DISABLE: gpio_pulldown_t = 0;
#[doc = "< Enable GPIO pull-down resistor"]
pub const gpio_pulldown_t_GPIO_PULLDOWN_ENABLE: gpio_pulldown_t = 1;
pub type gpio_pulldown_t = ::std::os::raw::c_uint;
#[doc = " @brief Configuration parameters of GPIO pad for gpio_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_config_t {
    #[doc = "< GPIO pin: set with bit mask, each bit maps to a GPIO"]
    pub pin_bit_mask: u32,
    #[doc = "< GPIO mode: set input/output mode"]
    pub mode: gpio_mode_t,
    #[doc = "< GPIO pull-up"]
    pub pull_up_en: gpio_pullup_t,
    #[doc = "< GPIO pull-down"]
    pub pull_down_en: gpio_pulldown_t,
    #[doc = "< GPIO interrupt type"]
    pub intr_type: gpio_int_type_t,
}
pub type gpio_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub type gpio_isr_handle_t = *mut ::core::ffi::c_void;
extern "C" {
    #[doc = " @brief GPIO common configuration"]
    #[doc = ""]
    #[doc = " Configure GPIO's Mode,pull-up,PullDown,IntrType"]
    #[doc = ""]
    #[doc = " @param  gpio_cfg  Pointer to GPIO configure struct"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_config(gpio_cfg: *const gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO set interrupt trigger type"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set the trigger type of e.g. of GPIO12, gpio_num should be GPIO_NUM_12 (12);"]
    #[doc = " @param  intr_type Interrupt type, select from gpio_int_type_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK  Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_set_intr_type(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO set output level"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set the output level of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  level Output level. 0: low ; 1: high"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO number error"]
    pub fn gpio_set_level(gpio_num: gpio_num_t, level: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO get input level"]
    #[doc = ""]
    #[doc = " @note   If the pad is not configured for input (or input and output) the returned value is always 0."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to get the logic level of e.g. pin GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - 0 the GPIO input level is 0"]
    #[doc = "     - 1 the GPIO input level is 1"]
    pub fn gpio_get_level(gpio_num: gpio_num_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  GPIO set direction"]
    #[doc = ""]
    #[doc = " Configure GPIO direction,such as output_only,input_only"]
    #[doc = ""]
    #[doc = " @param  gpio_num  Configure GPIO pins number, it should be GPIO number. If you want to set direction of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  mode GPIO direction"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    pub fn gpio_set_direction(gpio_num: gpio_num_t, mode: gpio_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Configure GPIO pull-up/pull-down resistors"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set pull up or down mode for e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  pull GPIO pull up/down mode."]
    #[doc = ""]
    #[doc = " @note   The GPIO of esp8266 can not be pulled down except RTC GPIO which can not be pulled up."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG : Parameter error"]
    pub fn gpio_set_pull_mode(gpio_num: gpio_num_t, pull: gpio_pull_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable GPIO wake-up function."]
    #[doc = ""]
    #[doc = " @note RTC IO can not use the wakeup function"]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number."]
    #[doc = ""]
    #[doc = " @param intr_type GPIO wake-up type. Only GPIO_INTR_LOW_LEVEL or GPIO_INTR_HIGH_LEVEL can be used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_wakeup_enable(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable GPIO wake-up function."]
    #[doc = ""]
    #[doc = " @note RTC IO can not use the wakeup function"]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_wakeup_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Register GPIO interrupt handler, the handler is an ISR."]
    #[doc = ""]
    #[doc = " This ISR function is called whenever any GPIO interrupt occurs. See"]
    #[doc = " the alternative gpio_install_isr_service() and"]
    #[doc = " gpio_isr_handler_add() API in order to have the driver support"]
    #[doc = " per-GPIO ISRs."]
    #[doc = ""]
    #[doc = " @param  fn  Interrupt handler function."]
    #[doc = " @param  no_use In order to be compatible with esp32, the parameter has no practical meaning and can be filled with 0."]
    #[doc = " @param  arg  Parameter for handler function"]
    #[doc = " @param  handle_no_use Pointer to return handle. In order to be compatible with esp32,the parameter has no practical meaning and can be filled with NULL."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success ;"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    #[doc = "     - ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    pub fn gpio_isr_register(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
        no_use: ::std::os::raw::c_int,
        handle_no_use: *mut gpio_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable pull-up on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @note  The GPIO of esp8266 can not be pulled down except RTC GPIO which can not be pulled up."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pullup_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable pull-up on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @note  The GPIO of esp8266 can not be pulled down except RTC GPIO which can not be pulled up."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pullup_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable pull-down on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @note  The GPIO of esp8266 can not be pulled down except RTC GPIO which can not be pulled up."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pulldown_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable pull-down on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @note  The GPIO of esp8266 can not be pulled down except RTC GPIO which can not be pulled up."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pulldown_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install the driver's GPIO ISR handler service, which allows per-pin GPIO interrupt handlers."]
    #[doc = ""]
    #[doc = " This function is incompatible with gpio_isr_register() - if that function is used, a single global ISR is registered for all GPIO interrupts. If this function is used, the ISR service provides a global GPIO ISR and individual pin handlers are registered via the gpio_isr_handler_add() function."]
    #[doc = ""]
    #[doc = " @param  no_use In order to be compatible with esp32, the parameter has no practical meaning and can be filled with 0."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NO_MEM No memory to install this service"]
    #[doc = "     - ESP_ERR_INVALID_STATE ISR service already installed."]
    #[doc = "     - ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    pub fn gpio_install_isr_service(no_use: ::std::os::raw::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall the driver's GPIO ISR service, freeing related resources."]
    pub fn gpio_uninstall_isr_service();
}
extern "C" {
    #[doc = " @brief Add ISR handler for the corresponding GPIO pin."]
    #[doc = ""]
    #[doc = " Call this function after using gpio_install_isr_service() to"]
    #[doc = " install the driver's GPIO ISR handler service."]
    #[doc = ""]
    #[doc = " This ISR handler will be called from an ISR. So there is a stack"]
    #[doc = " size limit (configurable as \"ISR stack size\" in menuconfig). This"]
    #[doc = " limit is smaller compared to a global GPIO interrupt handler due"]
    #[doc = " to the additional level of indirection."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = " @param isr_handler ISR handler function for the corresponding GPIO number."]
    #[doc = " @param args parameter for ISR handler."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Wrong state, the ISR service has not been initialized."]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_isr_handler_add(
        gpio_num: gpio_num_t,
        isr_handler: gpio_isr_t,
        args: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Remove ISR handler for the corresponding GPIO pin."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Wrong state, the ISR service has not been initialized."]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_isr_handler_remove(gpio_num: gpio_num_t) -> esp_err_t;
}
pub type __builtin_va_list = __va_list_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub __va_stk: *mut ::std::os::raw::c_int,
    pub __va_reg: *mut ::std::os::raw::c_int,
    pub __va_ndx: ::std::os::raw::c_int,
}
